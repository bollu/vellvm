<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Classes</title>
<meta name="description" content="Documentation of Coq module Classes" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Classes</h1>
<div class="coq">
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="id">Arguments</span>.<br/>
<span class="kwd">Set</span> <span class="id">Contextual</span> <span class="kwd">Implicit</span>.<br/>
<span class="kwd">Global</span> <span class="id">Generalizable</span> <span class="id">All</span> <span class="kwd">Variables</span>.<br/>
<span class="id">From</span> <span class="id">Coq</span> <span class="kwd">Require</span> <span class="kwd">Export</span> <span class="id">Morphisms</span> <span class="id">RelationClasses</span> <span class="id">Setoid</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">List</span> <span class="id">Bool</span> <span class="id">String</span> <span class="id">Utf8</span>. <br/>
<span class="kwd">Export</span> <span class="id">ListNotations</span>.<br/>
<span class="id">From</span> <span class="id">Coq.Program</span> <span class="kwd">Require</span> <span class="kwd">Export</span> <span class="id">Basics</span> <span class="kwd">Syntax</span>.<br/>
<br/>
<span class="id">Arguments</span> <span class="id">String.append</span> <span class="id">_</span> <span class="id">_</span> : <span class="tactic">simpl</span> <span class="id">never</span>.<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">t</span> $ <span class="id">r</span>" := (<span class="id">t</span> <span class="id">r</span>)<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">right</span> <span class="id">associativity</span>, <span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "($)" := (λ <span class="id">f</span> <span class="id">x</span>, <span class="id">f</span> <span class="id">x</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "($ <span class="id">x</span> )" := (λ <span class="id">f</span>, <span class="id">f</span> <span class="id">x</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Infix</span> "∘" := <span class="id">compose</span>.<br/>
<span class="kwd">Notation</span> "(∘)" := <span class="id">compose</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "( <span class="id">f</span> ∘)" := (<span class="id">compose</span> <span class="id">f</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(∘ <span class="id">f</span> )" := (λ <span class="id">g</span>, <span class="id">compose</span> <span class="id">g</span> <span class="id">f</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<div class="doc">Ensure that <span class="bracket"><span class="tactic">simpl</span></span> unfolds <span class="bracket"><span class="id">id</span></span>, <span class="bracket"><span class="id">compose</span></span>, and <span class="bracket"><span class="id">flip</span></span> when fully
applied. </div>
<span class="id">Arguments</span> <span class="id">id</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<span class="id">Arguments</span> <span class="id">compose</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<span class="id">Arguments</span> <span class="id">flip</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<span class="id">Arguments</span> <span class="id">const</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> /.<br/>
<span class="kwd">Typeclasses</span> <span class="id">Transparent</span> <span class="id">id</span> <span class="id">compose</span> <span class="id">flip</span> <span class="id">const</span>.<br/>
<br/>
<br/>
<br/>
<span class="kwd">Class</span> <span class="id">Equiv</span> <span class="id">A</span> := <span class="id">equiv</span>: <span class="id">relation</span> <span class="id">A</span>.<br/>
<span class="kwd">Infix</span> "≡" := <span class="id">equiv</span> (<span class="tactic">at</span> <span class="id">level</span> 70, <span class="id">no</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "(≡)" := <span class="id">equiv</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "( <span class="id">X</span> ≡)" := (<span class="id">equiv</span> <span class="id">X</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(≡ <span class="id">X</span> )" := (λ <span class="id">Y</span>, <span class="id">Y</span> ≡ <span class="id">X</span>) (<span class="id">only</span> <span class="id">parsing</span>). <br/>
<span class="kwd">Notation</span> "(≢)" := (λ <span class="id">X</span> <span class="id">Y</span>, ¬<span class="id">X</span> ≡ <span class="id">Y</span>) (<span class="id">only</span> <span class="id">parsing</span>). <br/>
<span class="kwd">Notation</span> "<span class="id">X</span> ≢ <span class="id">Y</span>":= (¬<span class="id">X</span> ≡ <span class="id">Y</span>) (<span class="tactic">at</span> <span class="id">level</span> 70, <span class="id">no</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "( <span class="id">X</span> ≢)" := (λ <span class="id">Y</span>, <span class="id">X</span> ≢ <span class="id">Y</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(≢ <span class="id">X</span> )" := (λ <span class="id">Y</span>, <span class="id">Y</span> ≢ <span class="id">X</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<br/>
<span class="kwd">Class</span> <span class="id">EquivProps</span> <span class="id">A</span> := {<br/>
&nbsp;&nbsp;&nbsp;<span class="id">EquivPropsEquiv</span> :&gt; <span class="id">Equiv</span> <span class="id">A</span> ;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">EquivPropsEquivalence</span> :&gt; <span class="id">Equivalence</span> (<span class="id">EquivPropsEquiv</span>) ;<br/>
}.<br/>
<br/>
<br/>
<div class="doc">The type class <span class="bracket"><span class="id">LeibnizEquiv</span></span> collects setoid equalities that coincide
with Leibniz equality. We provide the tactic <span class="bracket"><span class="id">fold_leibniz</span></span> to transform such
setoid equalities into Leibniz equalities, and <span class="bracket"><span class="id">unfold_leibniz</span></span> for the
reverse. </div>
<span class="kwd">Class</span> <span class="id">LeibnizEquiv</span> <span class="id">A</span> `{<span class="id">Equiv</span> <span class="id">A</span>} := <span class="id">leibniz_equiv</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">x</span> ≡ <span class="id">y</span> → <span class="id">x</span> = <span class="id">y</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">leibniz_equiv_iff</span> `{<span class="id">LeibnizEquiv</span> <span class="id">A</span>, !<span class="id">Reflexive</span> (@<span class="id">equiv</span> <span class="id">A</span> <span class="id">_</span>)} (<span class="id">x</span> <span class="id">y</span> : <span class="id">A</span>) :<br/>
&nbsp;&nbsp;<span class="id">x</span> ≡ <span class="id">y</span> ↔ <span class="id">x</span> = <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof52')">Proof.</div>
<div class="proofscript" id="proof52">
 <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">leibniz_equiv</span>. <span class="tactic">intros</span> -&gt;; <span class="tactic">reflexivity</span>. Qed.</div>
&nbsp;<br/>
<span class="kwd">Ltac</span> <span class="id">fold_leibniz</span> := <span class="tactic">repeat</span><br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">H</span> : <span class="id">context</span> [ @<span class="id">equiv</span> ?<span class="id">A</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> ] |- <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">setoid_rewrite</span> (<span class="id">leibniz_equiv_iff</span> (<span class="id">A</span>:=<span class="id">A</span>)) <span class="kwd">in</span> <span class="id">H</span><br/>
&nbsp;&nbsp;| |- <span class="id">context</span> [ @<span class="id">equiv</span> ?<span class="id">A</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">setoid_rewrite</span> (<span class="id">leibniz_equiv_iff</span> (<span class="id">A</span>:=<span class="id">A</span>))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<span class="kwd">Ltac</span> <span class="id">unfold_leibniz</span> := <span class="tactic">repeat</span><br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">H</span> : <span class="id">context</span> [ @<span class="id">eq</span> ?<span class="id">A</span> <span class="id">_</span> <span class="id">_</span> ] |- <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">setoid_rewrite</span> &lt;-(<span class="id">leibniz_equiv_iff</span> (<span class="id">A</span>:=<span class="id">A</span>)) <span class="kwd">in</span> <span class="id">H</span><br/>
&nbsp;&nbsp;| |- <span class="id">context</span> [ @<span class="id">eq</span> ?<span class="id">A</span> <span class="id">_</span> <span class="id">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">setoid_rewrite</span> &lt;-(<span class="id">leibniz_equiv_iff</span> (<span class="id">A</span>:=<span class="id">A</span>))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Equality ------------------------------------------------------------- </div>
<div class="doc">Introduce some Haskell style like notations. </div>
<span class="kwd">Notation</span> "(=)" := <span class="id">eq</span> (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "( <span class="id">x</span> =)" := (<span class="id">eq</span> <span class="id">x</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(= <span class="id">x</span> )" := (λ <span class="id">y</span>, <span class="id">eq</span> <span class="id">y</span> <span class="id">x</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(≠)" := (λ <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> ≠ <span class="id">y</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "( <span class="id">x</span> ≠)" := (λ <span class="id">y</span>, <span class="id">x</span> ≠ <span class="id">y</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(≠ <span class="id">x</span> )" := (λ <span class="id">y</span>, <span class="id">y</span> ≠ <span class="id">x</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Extern</span> 0 (<span class="id">_</span> = <span class="id">_</span>) =&gt; <span class="tactic">reflexivity</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Extern</span> 100 (<span class="id">_</span> ≠ <span class="id">_</span>) =&gt; <span class="tactic">discriminate</span>.<br/>
<br/>
<span class="kwd">Instance</span>: @<span class="id">PreOrder</span> <span class="id">A</span> (=).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof53')">Proof.</div>
<div class="proofscript" id="proof53">
 <span class="tactic">split</span>; <span class="tactic">repeat</span> <span class="tactic">intro</span>; <span class="tactic">congruence</span>. Qed.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">equivL</span> {<span class="id">A</span>} : <span class="id">Equiv</span> <span class="id">A</span> := (=).<br/>
<br/>
<div class="doc">A <span class="bracket"><span class="id">Params</span> <span class="id">f</span> <span class="id">n</span></span> instance forces the setoid rewriting mechanism not to
rewrite in the first <span class="bracket"><span class="id">n</span></span> arguments of the function <span class="bracket"><span class="id">f</span></span>. We will declare such
instances for all operational type classes in this development. </div>
<span class="kwd">Instance</span>: <span class="id">Params</span> (@<span class="id">equiv</span>) 2.<br/>
<br/>
<div class="doc">The following instance forces <span class="bracket"><span class="tactic">setoid_replace</span></span> to use setoid equality
(for types that have an <span class="bracket"><span class="id">Equiv</span></span> instance) rather than the standard Leibniz
equality. </div>
<span class="kwd">Instance</span> <span class="id">equiv_default_relation</span> `{<span class="id">Equiv</span> <span class="id">A</span>} : <span class="id">DefaultRelation</span> (≡) | 3.<br/>
<span class="kwd">Hint</span> <span class="kwd">Extern</span> 0 (<span class="id">_</span> ≡ <span class="id">_</span>) =&gt; <span class="tactic">reflexivity</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Extern</span> 0 (<span class="id">_</span> ≡ <span class="id">_</span>) =&gt; <span class="tactic">symmetry</span>; <span class="tactic">assumption</span>.<br/>
<br/>
<h1> Type classes </h1>
<br/>
<h2> Decidable propositions ---------------------------------------------- </h2>
<div class="doc">This type class by (Spitters/van der Weegen, 2011) collects decidable
propositions. For example to declare a parameter expressing decidable equality
on a type <span class="bracket"><span class="id">A</span></span> we write <span class="bracket">`{∀ <span class="id">x</span> <span class="id">y</span> : <span class="id">A</span>, <span class="id">Decidable</span> (<span class="id">x</span> = <span class="id">y</span>)}</span> and use it by writing
<span class="bracket"><span class="id">decide</span> (<span class="id">x</span> = <span class="id">y</span>)</span>. </div>
<br/>
<span class="kwd">Class</span> <span class="id">Decidable</span> (<span class="id">P</span> : <span class="kwd">Prop</span>) := <span class="id">decide</span> : {<span class="id">P</span>} + {¬<span class="id">P</span>}.<br/>
<span class="id">Arguments</span> <span class="id">decide</span> <span class="id">_</span> {<span class="id">_</span>}.<br/>
<span class="kwd">Notation</span> <span class="id">eq_dec</span> <span class="id">A</span> := (∀ <span class="id">x</span> <span class="id">y</span> : <span class="id">A</span>, <span class="id">Decidable</span> (<span class="id">x</span> = <span class="id">y</span>)).<br/>
<span class="kwd">Notation</span> "<span class="id">x</span> == <span class="id">y</span>" := (<span class="id">decide</span> (<span class="id">x</span> = <span class="id">y</span>)) (<span class="tactic">at</span> <span class="id">level</span> 70, <span class="id">no</span> <span class="id">associativity</span>).<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">decide_eq_dec</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ |- <span class="id">eq_dec</span> ?<span class="id">T</span> ] =&gt; <span class="tactic">intros</span> <span class="id">x</span> <span class="id">y</span>; <span class="tactic">unfold</span> <span class="id">Decidable</span>; <span class="id">decide</span> <span class="id">equality</span>; <span class="id">decide_eq_dec</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="id">eq_dec</span> ?<span class="id">T</span> |- {?<span class="id">X</span> = ?<span class="id">Y</span>} + {?<span class="id">X</span> &lt;&gt; ?<span class="id">Y</span>} ] =&gt; <span class="tactic">apply</span> <span class="id">H</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">eq_dec_bool</span> : <span class="id">eq_dec</span> <span class="id">bool</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof54')">Proof.</div>
<div class="proofscript" id="proof54">
&nbsp;&nbsp;<span class="id">decide_eq_dec</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">eq_dec_nat</span> : <span class="id">eq_dec</span> <span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof55')">Proof.</div>
<div class="proofscript" id="proof55">
&nbsp;&nbsp;<span class="id">decide_eq_dec</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">eq_dec_string</span> : <span class="id">eq_dec</span> <span class="id">string</span> := <span class="id">string_dec</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ZArith.ZArith</span>.<br/>
<span class="kwd">Instance</span> <span class="id">eq_dec_z</span> : <span class="id">eq_dec</span> <span class="id">Z</span> := <span class="id">Z.eq_dec</span>.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">eq_dec_pair</span> {<span class="id">A</span> <span class="id">B</span>} `(<span class="id">EA</span>:<span class="id">eq_dec</span> <span class="id">A</span>) `(<span class="id">EB</span>:<span class="id">eq_dec</span> <span class="id">B</span>) : <span class="id">eq_dec</span> (<span class="id">A</span> * <span class="id">B</span>)%<span class="id">type</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof56')">Proof.</div>
<div class="proofscript" id="proof56">
&nbsp;&nbsp;<span class="id">decide_eq_dec</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">eq_dec_option</span> {<span class="id">A</span>} `(<span class="id">EA</span>:<span class="id">eq_dec</span> <span class="id">A</span>) : <span class="id">eq_dec</span> (<span class="id">option</span> <span class="id">A</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof57')">Proof.</div>
<div class="proofscript" id="proof57">
&nbsp;&nbsp;<span class="id">decide_eq_dec</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">eq_dec_list</span> {<span class="id">A</span>} `(<span class="id">EA</span>:<span class="id">eq_dec</span> <span class="id">A</span>) : <span class="id">eq_dec</span> (<span class="id">list</span> <span class="id">A</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof58')">Proof.</div>
<div class="proofscript" id="proof58">
&nbsp;&nbsp;<span class="id">decide_eq_dec</span>.<br/>
Defined.</div>
<br/>
<h2> Functors ----------------------------------------------------------------- </h2>
<br/>
<span class="kwd">Class</span> <span class="id">Functor</span> (<span class="id">F</span>:<span class="kwd">Type</span> -&gt; <span class="kwd">Type</span>) := <span class="id">fmap</span> : <span class="kwd">forall</span> {<span class="id">A</span> <span class="id">B</span>}, (<span class="id">A</span> -&gt; <span class="id">B</span>) -&gt; <span class="id">F</span> <span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">B</span>.<br/>
<span class="kwd">Infix</span> "&lt;$&gt;" := <span class="id">fmap</span> (<span class="tactic">at</span> <span class="id">level</span> 60, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<br/>
<span class="kwd">Class</span> <span class="id">FunctorLaws</span> (<span class="id">F</span>:<span class="kwd">Type</span> -&gt; <span class="kwd">Type</span>) `{<span class="id">Functor</span> <span class="id">F</span>} `{<span class="id">eqiv</span>:<span class="kwd">forall</span> <span class="id">A</span>, <span class="id">Equiv</span> (<span class="id">F</span> <span class="id">A</span>)}    :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id">fmap_id</span> : <span class="kwd">forall</span> <span class="id">A</span> (<span class="id">a</span> : <span class="id">F</span> <span class="id">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">id</span> &lt;$&gt; <span class="id">a</span>) ≡ <span class="id">a</span>;<br/>
<br/>
&nbsp;&nbsp;<span class="id">fmap_comp</span> : <span class="kwd">forall</span> <span class="id">A</span> <span class="id">B</span> <span class="id">C</span> (<span class="id">f</span>:<span class="id">A</span> -&gt; <span class="id">B</span>) (<span class="id">g</span>:<span class="id">B</span> -&gt; <span class="id">C</span>) (<span class="id">a</span>:<span class="id">F</span> <span class="id">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g</span> &lt;$&gt; (<span class="id">f</span> &lt;$&gt; <span class="id">a</span>) ≡ (<span class="id">g</span> ∘ <span class="id">f</span>) &lt;$&gt; <span class="id">a</span>;<br/>
}.<br/>
<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">option_functor</span> : @<span class="id">Functor</span> <span class="id">option</span> := <span class="id">option_map</span>.<br/>
<span class="kwd">Instance</span> <span class="id">option_equiv</span> {<span class="id">A</span>} : <span class="id">Equiv</span> (<span class="id">option</span> <span class="id">A</span>) := (@<span class="id">eq</span> (<span class="id">option</span> <span class="id">A</span>)).<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">option_functor_eq_laws</span> : (@<span class="id">FunctorLaws</span> <span class="id">option</span>) <span class="id">option_functor</span> (@<span class="id">option_equiv</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof59')">Proof.</div>
<div class="proofscript" id="proof59">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">fmap</span>. <span class="tactic">unfold</span> <span class="id">option_functor</span>. <span class="tactic">unfold</span> <span class="id">option_map</span>. <span class="tactic">destruct</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">fmap</span>. <span class="tactic">unfold</span> <span class="id">option_functor</span>. <span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">list_functor</span>: @<span class="id">Functor</span> <span class="id">list</span> := <span class="id">List.map</span>.<br/>
<span class="kwd">Instance</span> <span class="id">list_equiv</span> {<span class="id">A</span>} : <span class="id">Equiv</span> (<span class="id">list</span> <span class="id">A</span>) := (@<span class="id">eq</span> (<span class="id">list</span> <span class="id">A</span>)).<br/>
<span class="kwd">Instance</span> <span class="id">list_functor_eq_laws</span> : (@<span class="id">FunctorLaws</span> <span class="id">list</span>) <span class="id">list_functor</span> (@<span class="id">list_equiv</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof60')">Proof.</div>
<div class="proofscript" id="proof60">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">List.map_id</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">List.map_map</span>.<br/>
Defined.</div>
<br/>
<h2> Monads ------------------------------------------------------------------- </h2>
<span class="kwd">Class</span> <span class="id">Monad</span> <span class="id">F</span> `{<span class="id">Functor</span> <span class="id">F</span>} :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id">mret</span> : <span class="kwd">forall</span> {<span class="id">A</span>}, <span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">A</span> ;<br/>
&nbsp;&nbsp;<span class="id">mbind</span> : <span class="kwd">forall</span> {<span class="id">A</span> <span class="id">B</span>}, <span class="id">F</span> <span class="id">A</span> -&gt; (<span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">B</span>) -&gt; <span class="id">F</span> <span class="id">B</span> ;<br/>
}.<br/>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">mret</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">mbind</span>.<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">m</span> ≫= <span class="id">f</span>"  := (<span class="id">mbind</span> <span class="id">m</span> <span class="id">f</span>) (<span class="tactic">at</span> <span class="id">level</span> 60, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "( <span class="id">m</span> ≫=)" := (<span class="id">mbind</span> <span class="id">m</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(≫= <span class="id">f</span> )" := (<span class="kwd">fun</span> <span class="id">m</span> =&gt; <span class="id">mbind</span> <span class="id">m</span> <span class="id">f</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "(≫=)"    := (λ <span class="id">m</span> <span class="id">f</span>, <span class="id">mbind</span> <span class="id">m</span> <span class="id">f</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<span class="kwd">Notation</span> "'; <span class="id">y</span> ; <span class="id">z</span>" := (<span class="id">y</span> ≫= (λ <span class="id">_</span> : (), <span class="id">z</span>))<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">only</span> <span class="id">parsing</span>, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "' <span class="id">x</span> &lt;- <span class="id">y</span> ; <span class="id">z</span>" := (<span class="id">y</span> ≫= (λ <span class="id">x</span> : <span class="id">_</span>, <span class="id">z</span>))<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">x</span> <span class="id">ident</span>, <span class="id">only</span> <span class="id">parsing</span>, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "' ( <span class="id">x1</span> , <span class="id">x2</span> ) &lt;- <span class="id">y</span> ; <span class="id">z</span>" :=<br/>
&nbsp;&nbsp;(<span class="id">y</span> ≫= (λ <span class="id">x</span> : <span class="id">_</span>, <span class="kwd">let</span> ' (<span class="id">x1</span>, <span class="id">x2</span>) := <span class="id">x</span> <span class="kwd">in</span> <span class="id">z</span>))<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">x1</span> <span class="id">ident</span>, <span class="id">x2</span> <span class="id">ident</span>, <span class="id">only</span> <span class="id">parsing</span>, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "' ( <span class="id">x1</span> , <span class="id">x2</span> , <span class="id">x3</span> ) &lt;- <span class="id">y</span> ; <span class="id">z</span>" :=<br/>
&nbsp;&nbsp;(<span class="id">y</span> ≫= (λ <span class="id">x</span> : <span class="id">_</span>, <span class="kwd">let</span> ' (<span class="id">x1</span>,<span class="id">x2</span>,<span class="id">x3</span>) := <span class="id">x</span> <span class="kwd">in</span> <span class="id">z</span>))<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">x1</span> <span class="id">ident</span>, <span class="id">x2</span> <span class="id">ident</span>, <span class="id">x3</span> <span class="id">ident</span>, <span class="id">only</span> <span class="id">parsing</span>, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "' ( <span class="id">x1</span> , <span class="id">x2</span> , <span class="id">x3</span>  , <span class="id">x4</span> ) &lt;- <span class="id">y</span> ; <span class="id">z</span>" :=<br/>
&nbsp;&nbsp;(<span class="id">y</span> ≫= (λ <span class="id">x</span> : <span class="id">_</span>, <span class="kwd">let</span> ' (<span class="id">x1</span>,<span class="id">x2</span>,<span class="id">x3</span>,<span class="id">x4</span>) := <span class="id">x</span> <span class="kwd">in</span> <span class="id">z</span>))<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">x1</span> <span class="id">ident</span>, <span class="id">x2</span> <span class="id">ident</span>, <span class="id">x3</span> <span class="id">ident</span>, <span class="id">x4</span> <span class="id">ident</span>, <span class="id">only</span> <span class="id">parsing</span>, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "' ( <span class="id">x1</span> , <span class="id">x2</span> , <span class="id">x3</span>  , <span class="id">x4</span> , <span class="id">x5</span> ) &lt;- <span class="id">y</span> ; <span class="id">z</span>" :=<br/>
&nbsp;&nbsp;(<span class="id">y</span> ≫= (λ <span class="id">x</span> : <span class="id">_</span>, <span class="kwd">let</span> ' (<span class="id">x1</span>,<span class="id">x2</span>,<span class="id">x3</span>,<span class="id">x4</span>,<span class="id">x5</span>) := <span class="id">x</span> <span class="kwd">in</span> <span class="id">z</span>))<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">x1</span> <span class="id">ident</span>, <span class="id">x2</span> <span class="id">ident</span>, <span class="id">x3</span> <span class="id">ident</span>, <span class="id">x4</span> <span class="id">ident</span>, <span class="id">x5</span> <span class="id">ident</span>, <span class="id">only</span> <span class="id">parsing</span>, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<span class="kwd">Notation</span> "' ( <span class="id">x1</span> , <span class="id">x2</span> , <span class="id">x3</span>  , <span class="id">x4</span> , <span class="id">x5</span> , <span class="id">x6</span> ) &lt;- <span class="id">y</span> ; <span class="id">z</span>" :=<br/>
&nbsp;&nbsp;(<span class="id">y</span> ≫= (λ <span class="id">x</span> : <span class="id">_</span>, <span class="kwd">let</span> ' (<span class="id">x1</span>,<span class="id">x2</span>,<span class="id">x3</span>,<span class="id">x4</span>,<span class="id">x5</span>,<span class="id">x6</span>) := <span class="id">x</span> <span class="kwd">in</span> <span class="id">z</span>))<br/>
&nbsp;&nbsp;(<span class="tactic">at</span> <span class="id">level</span> 65, <span class="id">x1</span> <span class="id">ident</span>, <span class="id">x2</span> <span class="id">ident</span>, <span class="id">x3</span> <span class="id">ident</span>, <span class="id">x4</span> <span class="id">ident</span>, <span class="id">x5</span> <span class="id">ident</span>, <span class="id">x6</span> <span class="id">ident</span>, <span class="id">only</span> <span class="id">parsing</span>, <span class="id">right</span> <span class="id">associativity</span>).<br/>
<br/>
<span class="kwd">Class</span> <span class="id">MonadLaws</span> <span class="id">F</span> `{<span class="id">Monad</span> <span class="id">F</span>} `{<span class="id">FunctorLaws</span> <span class="id">F</span>} :=<br/>
{<br/>
&nbsp;&nbsp;<span class="id">mbind_mret</span>  : <span class="kwd">forall</span> {<span class="id">A</span>} (<span class="id">a</span>: <span class="id">F</span> <span class="id">A</span>), (<span class="id">a</span> ≫= <span class="id">mret</span>) ≡ <span class="id">a</span>;<br/>
&nbsp;&nbsp;<span class="id">mret_mbind</span>  : <span class="kwd">forall</span> {<span class="id">A</span> <span class="id">B</span>:<span class="kwd">Type</span>} <span class="id">a</span> (<span class="id">f</span>:<span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">B</span>), (<span class="id">mret</span> <span class="id">a</span>) ≫= <span class="id">f</span> ≡ (<span class="id">f</span> <span class="id">a</span>);<br/>
&nbsp;&nbsp;<span class="id">mbind_assoc</span> : <span class="kwd">forall</span> {<span class="id">A</span> <span class="id">B</span> <span class="id">C</span>} (<span class="id">a</span> : <span class="id">F</span> <span class="id">A</span>) (<span class="id">f</span> : <span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">B</span>) (<span class="id">g</span> : <span class="id">B</span> -&gt; <span class="id">F</span> <span class="id">C</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">a</span> ≫= <span class="id">f</span>) ≫= <span class="id">g</span> ≡ <span class="id">a</span> ≫= (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">f</span> <span class="id">x</span> ≫= <span class="id">g</span>);<br/>
}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">monad_app_fst</span> `{<span class="id">Monad</span> <span class="id">F</span>} {<span class="id">A</span> <span class="id">B</span> <span class="id">C</span>} (<span class="id">f</span> : <span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">C</span>) (<span class="id">p</span>:<span class="id">A</span> * <span class="id">B</span>) : <span class="id">F</span> (<span class="id">C</span> * <span class="id">B</span>)%<span class="id">type</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> '(<span class="id">x</span>,<span class="id">y</span>) := <span class="id">p</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;'<span class="id">z</span> &lt;- <span class="id">f</span> <span class="id">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mret</span> (<span class="id">z</span>,<span class="id">y</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">monad_app_snd</span> `{<span class="id">Monad</span> <span class="id">F</span>} {<span class="id">A</span> <span class="id">B</span> <span class="id">C</span>} (<span class="id">f</span> : <span class="id">B</span> -&gt; <span class="id">F</span> <span class="id">C</span>) (<span class="id">p</span>:<span class="id">A</span> * <span class="id">B</span>) : <span class="id">F</span> (<span class="id">A</span> * <span class="id">C</span>)%<span class="id">type</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> '(<span class="id">x</span>,<span class="id">y</span>) := <span class="id">p</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;'<span class="id">z</span> &lt;- <span class="id">f</span> <span class="id">y</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mret</span> (<span class="id">x</span>,<span class="id">z</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">map_monad</span> `{<span class="id">Monad</span> <span class="id">F</span>} {<span class="id">A</span> <span class="id">B</span>} (<span class="id">f</span>:<span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">B</span>) (<span class="id">l</span>:<span class="id">list</span> <span class="id">A</span>) : <span class="id">F</span> (<span class="id">list</span> <span class="id">B</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">fix</span> <span class="id">loop</span> <span class="id">l</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; <span class="id">mret</span> []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">a</span>::<span class="id">l</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'<span class="id">b</span> &lt;- <span class="id">f</span> <span class="id">a</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'<span class="id">bs</span> &lt;- <span class="id">loop</span> <span class="id">l</span>';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mret</span> (<span class="id">b</span>::<span class="id">bs</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">loop</span> <span class="id">l</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FunctionalExtensionality</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">option_monad</span> : (@<span class="id">Monad</span> <span class="id">option</span>) <span class="id">option_functor</span> := <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof61')">Next Obligation.</div>
<div class="proofscript" id="proof61">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">X</span>. <span class="tactic">exact</span> (<span class="id">Some</span> <span class="id">X</span>).<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">B</span> <span class="id">X</span> <span class="id">X0</span>.  <span class="tactic">destruct</span> <span class="id">X</span>. <span class="tactic">apply</span> <span class="id">X0</span>. <span class="tactic">exact</span> <span class="id">a</span>. <span class="tactic">exact</span> <span class="id">None</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">option_monad_eq_laws</span> : (@<span class="id">MonadLaws</span> <span class="id">option</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof62')">Next Obligation.</div>
<div class="proofscript" id="proof62">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<div class="toggleproof" onclick="toggleDisplay('proof63')">Next Obligation.</div>
<div class="proofscript" id="proof63">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">list_monad</span> : (@<span class="id">Monad</span> <span class="id">list</span>) <span class="id">list_functor</span> := <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof64')">Next Obligation.</div>
<div class="proofscript" id="proof64">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">X</span>. <span class="tactic">exact</span> ([<span class="id">X</span>]).<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">B</span>. <span class="tactic">exact</span> (<span class="kwd">fun</span> <span class="id">l</span> <span class="id">f</span> =&gt; <span class="id">flat_map</span> <span class="id">f</span> <span class="id">l</span>).<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">list_monad_eq_laws</span> : (@<span class="id">MonadLaws</span> <span class="id">list</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof65')">Next Obligation.</div>
<div class="proofscript" id="proof65">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">IHa</span>. <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<div class="toggleproof" onclick="toggleDisplay('proof66')">Next Obligation.</div>
<div class="proofscript" id="proof66">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">app_nil_r</span>.<br/>
Defined.</div>
<div class="toggleproof" onclick="toggleDisplay('proof67')">Next Obligation.</div>
<div class="proofscript" id="proof67">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;-  <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="tactic">rewrite</span> <span class="id">flat_map_concat_map</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">map_app</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">concat_app</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="tactic">rewrite</span> &lt;- <span class="id">flat_map_concat_map</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHa</span>. <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">sum_map</span> {<span class="id">X</span> <span class="id">A</span> <span class="id">B</span>} (<span class="id">f</span> : <span class="id">A</span> -&gt; <span class="id">B</span>) (<span class="id">s</span>:<span class="id">X</span> + <span class="id">A</span>) : <span class="id">X</span> + <span class="id">B</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">inl</span> <span class="id">x</span> =&gt; <span class="id">inl</span> <span class="id">x</span><br/>
&nbsp;&nbsp;| <span class="id">inr</span> <span class="id">a</span> =&gt; <span class="id">inr</span> (<span class="id">f</span> <span class="id">a</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">sum_map</span>.<br/>
<span class="id">Arguments</span> <span class="id">sum_map</span> <span class="id">_</span> <span class="id">_</span> : <span class="tactic">simpl</span> <span class="id">nomatch</span>.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">sum_functor</span> {<span class="id">X</span>:<span class="kwd">Type</span>} : @<span class="id">Functor</span> (<span class="id">sum</span> <span class="id">X</span>) := (@<span class="id">sum_map</span> <span class="id">X</span>).<br/>
<span class="kwd">Instance</span> <span class="id">sum_equiv</span> {<span class="id">X</span>:<span class="kwd">Type</span>} <span class="id">A</span> : <span class="id">Equiv</span> (<span class="id">sum</span> <span class="id">X</span> <span class="id">A</span>) := (@<span class="id">eq</span> (<span class="id">sum</span> <span class="id">X</span> <span class="id">A</span>)).<br/>
<span class="kwd">Instance</span> <span class="id">sum_functor_eq_laws</span> {<span class="id">X</span>:<span class="kwd">Type</span>} : (@<span class="id">FunctorLaws</span>(<span class="id">sum</span> <span class="id">X</span>)) <span class="id">sum_functor</span> (@<span class="id">sum_equiv</span> <span class="id">X</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof68')">Proof.</div>
<div class="proofscript" id="proof68">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">fmap</span>. <span class="tactic">unfold</span> <span class="id">sum_functor</span>. <span class="tactic">unfold</span> <span class="id">sum_map</span>. <span class="tactic">destruct</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">fmap</span>. <span class="tactic">unfold</span> <span class="id">sum_functor</span>. <span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">sum_monad</span> {<span class="id">X</span>:<span class="kwd">Type</span>} : (@<span class="id">Monad</span> (<span class="id">sum</span> <span class="id">X</span>)) <span class="id">sum_functor</span> := <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof69')">Next Obligation.</div>
<div class="proofscript" id="proof69">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">a</span>. <span class="tactic">exact</span> (<span class="id">inr</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">B</span> <span class="id">x</span> <span class="id">f</span>.  <span class="tactic">destruct</span> <span class="id">x</span>. <span class="id">left</span>. <span class="tactic">exact</span> <span class="id">x</span>. <span class="tactic">apply</span> <span class="id">f</span>. <span class="tactic">exact</span> <span class="id">a</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">sum_monad_eq_laws</span> {<span class="id">X</span>:<span class="kwd">Type</span>} : (@<span class="id">MonadLaws</span> (<span class="id">sum</span> <span class="id">X</span>)) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof70')">Next Obligation.</div>
<div class="proofscript" id="proof70">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<div class="toggleproof" onclick="toggleDisplay('proof71')">Next Obligation.</div>
<div class="proofscript" id="proof71">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cont</span> (<span class="id">A</span>:<span class="kwd">Type</span>) := (<span class="id">A</span> -&gt; <span class="id">False</span>) -&gt; <span class="id">False</span>.<br/>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">cont_functor</span> : (@<span class="id">Functor</span> <span class="id">cont</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof72')">Next Obligation.</div>
<div class="proofscript" id="proof72">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cont</span> <span class="kwd">in</span> *. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">X</span> <span class="kwd">in</span> <span class="id">X0</span>. <span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">X0</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">cont_equiv</span> <span class="id">A</span> : <span class="id">Equiv</span> (<span class="id">cont</span> <span class="id">A</span>) := (@<span class="id">eq</span> (<span class="id">cont</span> <span class="id">A</span>)).<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">cont_functor_laws_eq</span> : (@<span class="id">FunctorLaws</span> <span class="id">cont</span>) <span class="id">cont_functor</span> (@<span class="id">cont_equiv</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof73')">Proof.</div>
<div class="proofscript" id="proof73">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">cont_monad</span> : (@<span class="id">Monad</span> <span class="id">cont</span>) <span class="id">cont_functor</span> := <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof74')">Next Obligation.</div>
<div class="proofscript" id="proof74">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">cont</span>. <span class="tactic">exact</span> (<span class="kwd">fun</span> (<span class="id">k</span> : <span class="id">A</span> -&gt; <span class="id">False</span>) =&gt; <span class="id">k</span> <span class="id">X</span>).<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">B</span> <span class="id">f</span> <span class="id">g</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cont</span> <span class="kwd">in</span> *. <span class="tactic">intros</span> <span class="id">k</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">f</span>. <span class="tactic">intros</span> <span class="id">a</span>. <span class="tactic">apply</span> <span class="id">g</span>. <span class="tactic">exact</span> <span class="id">a</span>. <span class="tactic">exact</span> <span class="id">k</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">cont_monad_eq_laws</span> : (@<span class="id">MonadLaws</span> <span class="id">cont</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FunctionalExtensionality</span>.<br/>
<span class="kwd">Definition</span> <span class="id">ST</span> (<span class="id">M</span>:<span class="kwd">Type</span>) (<span class="id">A</span>:<span class="kwd">Type</span>) := <span class="id">M</span> -&gt; (<span class="id">M</span> * <span class="id">A</span>).<br/>
<span class="kwd">Definition</span> <span class="id">st_map</span> {<span class="id">M</span> <span class="id">A</span> <span class="id">B</span>} (<span class="id">f</span> : <span class="id">A</span> -&gt; <span class="id">B</span>) (<span class="id">s</span> : <span class="id">ST</span> <span class="id">M</span> <span class="id">A</span>) : <span class="id">ST</span> <span class="id">M</span> <span class="id">B</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> (<span class="id">m</span>:<span class="id">M</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">m</span>', <span class="id">x</span>) := <span class="id">s</span> <span class="id">m</span> <span class="kwd">in</span> (<span class="id">m</span>', <span class="id">f</span> <span class="id">x</span>).<br/>
<span class="kwd">Definition</span> <span class="id">st_ret</span> {<span class="id">M</span> <span class="id">A</span>} : <span class="id">A</span> -&gt; <span class="id">ST</span> <span class="id">M</span> <span class="id">A</span> := <span class="kwd">fun</span> (<span class="id">x</span>:<span class="id">A</span>) =&gt; <span class="kwd">fun</span> (<span class="id">m</span>: <span class="id">M</span>) =&gt; (<span class="id">m</span>, <span class="id">x</span>).<br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">st_ret</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">st_bind</span> {<span class="id">M</span> <span class="id">A</span> <span class="id">B</span>} : (<span class="id">ST</span> <span class="id">M</span> <span class="id">A</span>) -&gt; (<span class="id">A</span> -&gt; <span class="id">ST</span> <span class="id">M</span> <span class="id">B</span>) -&gt; <span class="id">ST</span> <span class="id">M</span> <span class="id">B</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">s</span> =&gt; <span class="kwd">fun</span> <span class="id">f</span> =&gt; <span class="kwd">fun</span> <span class="id">m</span> =&gt; <span class="kwd">let</span> (<span class="id">m</span>', <span class="id">x</span>) := <span class="id">s</span> <span class="id">m</span> <span class="kwd">in</span> <span class="id">f</span> <span class="id">x</span> <span class="id">m</span>'.            <br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">st_bind</span>.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">st_functor</span> {<span class="id">M</span>} : (@<span class="id">Functor</span> (<span class="id">ST</span> <span class="id">M</span>)) := (@<span class="id">st_map</span> <span class="id">M</span>).<br/>
<span class="kwd">Instance</span> <span class="id">st_equiv</span> {<span class="id">M</span>} <span class="id">A</span> : <span class="id">Equiv</span> (<span class="id">ST</span> <span class="id">M</span> <span class="id">A</span>) := (@<span class="id">eq</span> (<span class="id">ST</span> <span class="id">M</span> <span class="id">A</span>)).<br/>
<span class="kwd">Instance</span> <span class="id">st_functor_eq_laws</span> {<span class="id">M</span>} `{<span class="id">Equiv</span> <span class="id">M</span>} : (@<span class="id">FunctorLaws</span> (<span class="id">ST</span> <span class="id">M</span>)) <span class="id">st_functor</span> (@<span class="id">st_equiv</span> <span class="id">M</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof75')">Proof.</div>
<div class="proofscript" id="proof75">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">a</span>. <span class="tactic">unfold</span> <span class="id">fmap</span>. <span class="tactic">unfold</span> <span class="id">st_functor</span>. <span class="tactic">unfold</span> <span class="id">st_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ST</span> <span class="kwd">in</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functional_extensionality</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">a</span> <span class="id">x</span>). <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A</span> <span class="id">B</span> <span class="id">C</span> <span class="id">f</span> <span class="id">g</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fmap</span>. <span class="tactic">unfold</span> <span class="id">st_functor</span>. <span class="tactic">unfold</span> <span class="id">st_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functional_extensionality</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">a</span> <span class="id">x</span>). <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">st_monad</span> : <span class="kwd">forall</span> <span class="id">A</span>, (@<span class="id">Monad</span> (<span class="id">ST</span> <span class="id">A</span>)) <span class="id">st_functor</span> := <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof76')">Next Obligation.</div>
<div class="proofscript" id="proof76">
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A0</span> <span class="id">X</span>. <span class="tactic">unfold</span> <span class="id">ST</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">A0</span> <span class="id">B</span> <span class="id">X</span> <span class="id">X0</span>. <span class="tactic">unfold</span> <span class="id">ST</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">X</span> <span class="kwd">in</span> <span class="id">X1</span>. <span class="tactic">destruct</span> <span class="id">X1</span> <span class="kwd">as</span> [<span class="id">a</span> <span class="id">b</span>]. <span class="tactic">apply</span> <span class="id">X0</span>; <span class="tactic">auto</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">st_monad_eq_laws</span> : <span class="kwd">forall</span> <span class="id">A</span>, (@<span class="id">MonadLaws</span> (<span class="id">ST</span> <span class="id">A</span>)) <span class="id">st_functor</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof77')">Next Obligation.</div>
<div class="proofscript" id="proof77">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functional_extensionality</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">x</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">a</span> <span class="id">x</span>). <span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<div class="toggleproof" onclick="toggleDisplay('proof78')">Next Obligation.</div>
<div class="proofscript" id="proof78">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functional_extensionality</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">a</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">a1</span> <span class="id">a0</span>).<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Defined.</div>
<br/>
<br/>
<span class="kwd">Class</span> <span class="id">ExceptionMonad</span> <span class="id">E</span> <span class="id">F</span> `{<span class="id">Monad</span> <span class="id">F</span>} :=<br/>
&nbsp;&nbsp;{ <span class="id">raise</span> : <span class="kwd">forall</span> {<span class="id">A</span>}, <span class="id">E</span> -&gt; <span class="id">F</span> <span class="id">A</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">catch</span> : <span class="kwd">forall</span> {<span class="id">A</span>}, <span class="id">F</span> <span class="id">A</span> -&gt; (<span class="id">E</span> -&gt; <span class="id">F</span> <span class="id">A</span>) -&gt; <span class="id">F</span> <span class="id">A</span> }<br/>
.<br/>
<br/>
<span class="kwd">Class</span> <span class="id">ExceptionMonadLaws</span> `{<span class="id">ExceptionMonad</span> <span class="id">M</span>} :=<br/>
&nbsp;&nbsp;{ <span class="id">raise_absorb</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">A</span> <span class="id">B</span>} <span class="id">e</span> (<span class="id">k</span>: <span class="id">A</span> -&gt; <span class="id">F</span> <span class="id">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">raise</span> <span class="id">e</span> ≫= <span class="id">k</span> = <span class="id">raise</span> <span class="id">e</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">catch_raise</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">A</span>: <span class="kwd">Type</span>} <span class="id">e</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">catch</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span> (<span class="id">raise</span> <span class="id">e</span>) <span class="id">k</span> = <span class="id">k</span> <span class="id">e</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">catch_pure</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">A</span>: <span class="kwd">Type</span>} <span class="id">x</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<span class="id">catch</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span> (<span class="id">mret</span> <span class="id">x</span>) <span class="id">k</span> = <span class="id">mret</span> <span class="id">x</span><br/>
&nbsp;&nbsp;}<br/>
.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">err</span> := <span class="id">sum</span> <span class="id">string</span>.<br/>
<span class="kwd">Instance</span> <span class="id">err_error</span> : (@<span class="id">ExceptionMonad</span> <span class="id">string</span> <span class="id">err</span> <span class="id">_</span> <span class="id">_</span>) :=<br/>
&nbsp;&nbsp;{| <span class="id">raise</span> := <span class="kwd">fun</span> <span class="id">_</span> (<span class="id">s</span>:<span class="id">string</span>) =&gt; <span class="id">inl</span> <span class="id">s</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">catch</span> := <span class="kwd">fun</span> <span class="id">_</span> <span class="id">e</span> <span class="id">k</span> =&gt; <span class="kwd">match</span> <span class="id">e</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">inl</span> <span class="id">e</span> =&gt; <span class="id">k</span> <span class="id">e</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">inr</span> <span class="id">x</span> =&gt; <span class="id">inr</span> <span class="id">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span> |}.<br/>
<br/>
<span class="kwd">Program</span> <span class="kwd">Instance</span> <span class="id">err_error_laws</span> : (@<span class="id">ExceptionMonadLaws</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">err_error</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">trywith</span> {<span class="id">A</span>:<span class="kwd">Type</span>} {<span class="id">F</span>} `{<span class="id">ExceptionMonad</span> <span class="id">string</span> <span class="id">F</span>} (<span class="id">s</span>:<span class="id">string</span>) (<span class="id">o</span>:<span class="id">option</span> <span class="id">A</span>) : <span class="id">F</span> <span class="id">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">o</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">x</span> =&gt; <span class="id">mret</span> <span class="id">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">raise</span> <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">trywith</span>.<br/>
<span class="id">Arguments</span> <span class="id">trywith</span> <span class="id">_</span> <span class="id">_</span> : <span class="tactic">simpl</span> <span class="id">nomatch</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">failwith</span> {<span class="id">A</span>:<span class="kwd">Type</span>} {<span class="id">F</span>} `{<span class="id">ExceptionMonad</span> <span class="id">string</span> <span class="id">F</span>} (<span class="id">s</span>:<span class="id">string</span>) : <span class="id">F</span> <span class="id">A</span> := <span class="id">raise</span> <span class="id">s</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">failwith</span>.<br/>
<span class="id">Arguments</span> <span class="id">failwith</span> <span class="id">_</span> <span class="id">_</span> : <span class="tactic">simpl</span> <span class="id">nomatch</span>.<br/>
<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">monad_fold_right</span> {<span class="id">A</span> <span class="id">B</span>} `{<span class="id">Monad</span> <span class="id">M</span>} (<span class="id">f</span> : <span class="id">A</span> -&gt; <span class="id">B</span> -&gt; <span class="id">M</span> <span class="id">A</span>) (<span class="id">l</span>:<span class="id">list</span> <span class="id">B</span>) (<span class="id">a</span>:<span class="id">A</span>) : <span class="id">M</span> <span class="id">A</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [] =&gt; <span class="id">mret</span> <span class="id">a</span><br/>
&nbsp;&nbsp;| <span class="id">x</span>::<span class="id">xs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;'<span class="id">y</span> &lt;- <span class="id">monad_fold_right</span> <span class="id">f</span> <span class="id">xs</span> <span class="id">a</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">y</span> <span class="id">x</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<span class="kwd">Class</span> <span class="id">StringOf</span> (<span class="id">T</span>:<span class="kwd">Type</span>) := <span class="id">string_of</span> : <span class="id">T</span> -&gt; <span class="id">string</span>.<br/>
<span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">string_scope</span>.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">string_of_string</span> : <span class="id">StringOf</span> <span class="id">string</span> := <span class="kwd">fun</span> <span class="id">s</span> =&gt; <span class="id">s</span>.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">string_of_bool</span> : <span class="id">StringOf</span> <span class="id">bool</span> := <span class="kwd">fun</span> (<span class="id">b</span>:<span class="id">bool</span>) =&gt; <span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> "<span class="id">true</span>" <span class="kwd">else</span> "<span class="id">false</span>".<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">string_of_pair</span> {<span class="id">A</span> <span class="id">B</span>} `(<span class="id">SA</span>:<span class="id">StringOf</span> <span class="id">A</span>) `(<span class="id">SB</span>:<span class="id">StringOf</span> <span class="id">B</span>) : <span class="id">StringOf</span> (<span class="id">A</span> * <span class="id">B</span>)%<span class="id">type</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">p</span> =&gt; "(" ++ <span class="id">string_of</span> (<span class="id">fst</span> <span class="id">p</span>) ++ ", " ++ <span class="id">string_of</span> (<span class="id">snd</span> <span class="id">p</span>) ++ ")".<br/>
&nbsp;&nbsp;<br/>
<span class="kwd">Instance</span> <span class="id">string_of_option</span> {<span class="id">A</span>} `(<span class="id">SA</span>:<span class="id">StringOf</span> <span class="id">A</span>) : <span class="id">StringOf</span> (<span class="id">option</span> <span class="id">A</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">opt</span> =&gt; <span class="kwd">match</span> <span class="id">opt</span> <span class="kwd">with</span> <span class="id">None</span> =&gt; "<span class="id">None</span>" | <span class="id">Some</span> <span class="id">x</span> =&gt; "<span class="id">Some</span> " ++ (<span class="id">string_of</span> <span class="id">x</span>) <span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">string_of_list_contents</span> {<span class="id">A</span>} `{<span class="id">SA</span>:<span class="id">StringOf</span> <span class="id">A</span>} (<span class="id">l</span>:<span class="id">list</span> <span class="id">A</span>) : <span class="id">string</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [] =&gt; ""<br/>
&nbsp;&nbsp;| <span class="id">x</span>::[] =&gt; <span class="id">string_of</span> <span class="id">x</span><br/>
&nbsp;&nbsp;| <span class="id">x</span>::<span class="id">rest</span> =&gt; <span class="id">string_of</span> <span class="id">x</span> ++ "; " ++ (<span class="id">string_of_list_contents</span> <span class="id">rest</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">string_of_list</span> {<span class="id">A</span>} `(<span class="id">SA</span>: <span class="id">StringOf</span> <span class="id">A</span>) : <span class="id">StringOf</span> (<span class="id">list</span> <span class="id">A</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">l</span> =&gt; "[" ++ (<span class="id">string_of_list_contents</span> <span class="id">l</span>) ++ "]".<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">digit_to_string</span> (<span class="id">x</span>:<span class="id">Z</span>) : <span class="id">string</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Z0</span> =&gt; "0"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (1%<span class="id">positive</span>) =&gt; "1"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (2%<span class="id">positive</span>) =&gt; "2"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (3%<span class="id">positive</span>) =&gt; "3"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (4%<span class="id">positive</span>) =&gt; "4"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (5%<span class="id">positive</span>) =&gt; "5"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (6%<span class="id">positive</span>) =&gt; "6"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (7%<span class="id">positive</span>) =&gt; "7"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (8%<span class="id">positive</span>) =&gt; "8"<br/>
&nbsp;&nbsp;| <span class="id">Zpos</span> (9%<span class="id">positive</span>) =&gt; "9"<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; "<span class="id">ERR</span>"<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">to_string_b10</span>' <span class="id">fuel</span> (<span class="id">x</span>:<span class="id">Z</span>) : <span class="id">string</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">fuel</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| 0 =&gt; "<span class="id">ERR</span>: <span class="id">not</span> <span class="id">enough</span> <span class="id">fuel</span>"<br/>
&nbsp;&nbsp;| <span class="id">S</span> <span class="id">f</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Z0</span> =&gt; "0"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="kwd">let</span> '(<span class="id">q</span>,<span class="id">r</span>) := (<span class="id">Z.div_eucl</span> <span class="id">x</span> 10) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">q</span> == <span class="id">Z0</span> <span class="kwd">then</span> (<span class="id">digit_to_string</span> <span class="id">r</span>) <span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">to_string_b10</span>' <span class="id">f</span> <span class="id">q</span>) ++ (<span class="id">digit_to_string</span> <span class="id">r</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">to_string_b10</span> := <span class="id">to_string_b10</span>' 1000.<br/>
<br/>
<span class="kwd">Instance</span> <span class="id">string_of_Z</span> : <span class="id">StringOf</span> <span class="id">Z</span> := <span class="id">to_string_b10</span>.</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
