<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module LLVMAst</title>
<meta name="description" content="Documentation of Coq module LLVMAst" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module LLVMAst</h1>
<div class="coq">
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">compcert.lib.Floats</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">List</span> <span class="id">String</span> <span class="id">Ascii</span> <span class="id">ZArith</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Vellvm.Util</span>.<br/>
<br/>
<br/>
<span class="kwd">Import</span> <span class="id">ListNotations</span>.<br/>
<span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">string_scope</span>.<br/>
<span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">list_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">int</span> := <span class="id">Z</span>.<br/>
<span class="kwd">Definition</span> <span class="id">float</span> := <span class="id">Floats.float</span>.  <br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">linkage</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">LINKAGE_Private</span><br/>
| <span class="id">LINKAGE_Internal</span><br/>
| <span class="id">LINKAGE_Available_externally</span><br/>
| <span class="id">LINKAGE_Linkonce</span><br/>
| <span class="id">LINKAGE_Weak</span><br/>
| <span class="id">LINKAGE_Common</span><br/>
| <span class="id">LINKAGE_Appending</span><br/>
| <span class="id">LINKAGE_Extern_weak</span><br/>
| <span class="id">LINKAGE_Linkonce_odr</span><br/>
| <span class="id">LINKAGE_Weak_odr</span><br/>
| <span class="id">LINKAGE_External</span><br/>
.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">eq_dec_linkage</span>: <span class="kwd">forall</span> (<span class="id">l1</span> <span class="id">l2</span>: <span class="id">linkage</span>), {<span class="id">l1</span> = <span class="id">l2</span>} + {<span class="id">l1</span> &lt;&gt; <span class="id">l2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</div>
<div class="proofscript" id="proof1">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>.<br/>
Qed.</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="kwd">Inductive</span> <span class="id">dll_storage</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">DLLSTORAGE_Dllimport</span><br/>
| <span class="id">DLLSTORAGE_Dllexport</span><br/>
.      <br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">eq_dec_dll_storage</span>: <span class="kwd">forall</span> (<span class="id">ds1</span> <span class="id">ds2</span>: <span class="id">dll_storage</span>), {<span class="id">ds1</span> = <span class="id">ds2</span>} + {<span class="id">ds1</span> &lt;&gt; <span class="id">ds2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</div>
<div class="proofscript" id="proof2">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">visibility</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">VISIBILITY_Default</span><br/>
| <span class="id">VISIBILITY_Hidden</span><br/>
| <span class="id">VISIBILITY_Protected</span><br/>
.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">eq_dec_visibility</span>: <span class="kwd">forall</span> (<span class="id">v1</span> <span class="id">v2</span>: <span class="id">visibility</span>), {<span class="id">v1</span> = <span class="id">v2</span>} + {<span class="id">v1</span> &lt;&gt; <span class="id">v2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</div>
<div class="proofscript" id="proof3">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>.<br/>
Qed.</div>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="kwd">Inductive</span> <span class="id">cconv</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">CC_Ccc</span><br/>
| <span class="id">CC_Fastcc</span><br/>
| <span class="id">CC_Coldcc</span><br/>
| <span class="id">CC_Cc</span> (<span class="id">cc</span>:<span class="id">int</span>)<br/>
.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="kwd">Inductive</span> <span class="id">param_attr</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">PARAMATTR_Zeroext</span><br/>
| <span class="id">PARAMATTR_Signext</span><br/>
| <span class="id">PARAMATTR_Inreg</span><br/>
| <span class="id">PARAMATTR_Byval</span><br/>
| <span class="id">PARAMATTR_Inalloca</span><br/>
| <span class="id">PARAMATTR_Sret</span><br/>
| <span class="id">PARAMATTR_Align</span> (<span class="id">a</span>:<span class="id">int</span>)<br/>
| <span class="id">PARAMATTR_Noalias</span><br/>
| <span class="id">PARAMATTR_Nocapture</span><br/>
| <span class="id">PARAMATTR_Readonly</span><br/>
| <span class="id">PARAMATTR_Nest</span><br/>
| <span class="id">PARAMATTR_Returned</span><br/>
| <span class="id">PARAMATTR_Nonnull</span><br/>
| <span class="id">PARAMATTR_Dereferenceable</span> (<span class="id">a</span>:<span class="id">int</span>)<br/>
.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="kwd">Inductive</span> <span class="id">fn_attr</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">FNATTR_Alignstack</span> (<span class="id">a</span>:<span class="id">int</span>)<br/>
| <span class="id">FNATTR_Alwaysinline</span><br/>
| <span class="id">FNATTR_Builtin</span><br/>
| <span class="id">FNATTR_Cold</span><br/>
| <span class="id">FNATTR_Inlinehint</span><br/>
| <span class="id">FNATTR_Jumptable</span><br/>
| <span class="id">FNATTR_Minsize</span><br/>
| <span class="id">FNATTR_Naked</span><br/>
| <span class="id">FNATTR_Nobuiltin</span><br/>
| <span class="id">FNATTR_Noduplicate</span><br/>
| <span class="id">FNATTR_Noimplicitfloat</span><br/>
| <span class="id">FNATTR_Noinline</span><br/>
| <span class="id">FNATTR_Nonlazybind</span><br/>
| <span class="id">FNATTR_Noredzone</span><br/>
| <span class="id">FNATTR_Noreturn</span><br/>
| <span class="id">FNATTR_Nounwind</span><br/>
| <span class="id">FNATTR_Optnone</span><br/>
| <span class="id">FNATTR_Optsize</span><br/>
| <span class="id">FNATTR_Readnone</span><br/>
| <span class="id">FNATTR_Readonly</span><br/>
| <span class="id">FNATTR_Returns_twice</span><br/>
| <span class="id">FNATTR_Sanitize_address</span><br/>
| <span class="id">FNATTR_Sanitize_memory</span><br/>
| <span class="id">FNATTR_Sanitize_thread</span><br/>
| <span class="id">FNATTR_Ssp</span><br/>
| <span class="id">FNATTR_Sspreq</span><br/>
| <span class="id">FNATTR_Sspstrong</span><br/>
| <span class="id">FNATTR_Uwtable</span><br/>
| <span class="id">FNATTR_String</span> (<span class="id">s</span>:<span class="id">string</span>) <br/>
| <span class="id">FNATTR_Key_value</span> (<span class="id">kv</span> : <span class="id">string</span> * <span class="id">string</span>) <br/>
| <span class="id">FNATTR_Attr_grp</span> (<span class="id">g</span>:<span class="id">int</span>)<br/>
.<br/>
<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">raw_id</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">Name</span> (<span class="id">s</span>:<span class="id">string</span>)       <br/>
| <span class="id">Anon</span> (<span class="id">n</span>:<span class="id">int</span>)        <br/>
| <span class="id">Raw</span>  (<span class="id">n</span>:<span class="id">int</span>)        <br/>
.<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">string_dec</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">Integers.Int.eq_dec</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">Z.eq_dec</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">Bool.bool_dec</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">Float.eq_dec</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">eq_dec_raw_id</span>: <span class="kwd">forall</span> (<span class="id">r1</span> <span class="id">r2</span>: <span class="id">raw_id</span>), {<span class="id">r1</span> = <span class="id">r2</span>} + {<span class="id">r1</span> &lt;&gt; <span class="id">r2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</div>
<div class="proofscript" id="proof4">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">eq_dec_raw_id</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">ident</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">ID_Global</span> (<span class="id">id</span>:<span class="id">raw_id</span>)   <br/>
| <span class="id">ID_Local</span>  (<span class="id">id</span>:<span class="id">raw_id</span>)   <br/>
.<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">ident_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">a</span> <span class="id">b</span>: <span class="id">ident</span>), {<span class="id">a</span> = <span class="id">b</span> } + {<span class="id">a</span> &lt;&gt; <span class="id">b</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</div>
<div class="proofscript" id="proof5">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">ident_eq_dec</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">local_id</span>  := <span class="id">raw_id</span>.<br/>
<span class="kwd">Definition</span> <span class="id">global_id</span> := <span class="id">raw_id</span>.<br/>
<span class="kwd">Definition</span> <span class="id">block_id</span> := <span class="id">raw_id</span>.<br/>
<span class="kwd">Definition</span> <span class="id">function_id</span> := <span class="id">global_id</span>.<br/>
<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">typ</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">TYPE_I</span> (<span class="id">sz</span>:<span class="id">int</span>)<br/>
| <span class="id">TYPE_Pointer</span> (<span class="id">t</span>:<span class="id">typ</span>)<br/>
| <span class="id">TYPE_Void</span><br/>
| <span class="id">TYPE_Half</span><br/>
| <span class="id">TYPE_Float</span><br/>
| <span class="id">TYPE_Double</span><br/>
| <span class="id">TYPE_X86_fp80</span><br/>
| <span class="id">TYPE_Fp128</span><br/>
| <span class="id">TYPE_Ppc_fp128</span><br/>
| <span class="id">TYPE_Metadata</span><br/>
| <span class="id">TYPE_X86_mmx</span><br/>
| <span class="id">TYPE_Array</span> (<span class="id">sz</span>:<span class="id">int</span>) (<span class="id">t</span>:<span class="id">typ</span>)<br/>
| <span class="id">TYPE_Function</span> (<span class="id">ret</span>:<span class="id">typ</span>) (<span class="id">args</span>:<span class="id">list</span> <span class="id">typ</span>)<br/>
| <span class="id">TYPE_Struct</span> (<span class="id">fields</span>:<span class="id">list</span> <span class="id">typ</span>)<br/>
| <span class="id">TYPE_Packed_struct</span> (<span class="id">fields</span>:<span class="id">list</span> <span class="id">typ</span>)<br/>
| <span class="id">TYPE_Opaque</span><br/>
| <span class="id">TYPE_Vector</span> (<span class="id">sz</span>:<span class="id">int</span>) (<span class="id">t</span>:<span class="id">typ</span>)     <br/>
| <span class="id">TYPE_Identified</span> (<span class="id">id</span>:<span class="id">ident</span>)<br/>
.<br/>
<br/>
<span class="kwd">Scheme</span> <span class="id">typ_ind_scheme</span> := <span class="kwd">Induction</span> <span class="kwd">for</span> <span class="id">typ</span> <span class="kwd">Sort</span> <span class="kwd">Type</span>.<br/>
<br/>
<br/>
<span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">list_scope</span>.<br/>
<span class="kwd">Section</span> <span class="id">typ_nested_ind</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Variable</span> <span class="id">P</span>: <span class="id">typ</span> -&gt; <span class="kwd">Type</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">I</span>: <span class="kwd">forall</span> <span class="id">sz</span>: <span class="id">int</span>, <span class="id">P</span> (<span class="id">TYPE_I</span> <span class="id">sz</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">POINTER</span>: <span class="kwd">forall</span> (<span class="id">t</span>: <span class="id">typ</span>), <span class="id">P</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span> (<span class="id">TYPE_Pointer</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">VOID</span>: <span class="id">P</span> (<span class="id">TYPE_Void</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">HALF</span>: <span class="id">P</span> (<span class="id">TYPE_Half</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">FLOAT</span>: <span class="id">P</span> (<span class="id">TYPE_Float</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">DOUBLE</span>: <span class="id">P</span> (<span class="id">TYPE_Double</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">X86_fp80</span>: <span class="id">P</span> (<span class="id">TYPE_X86_fp80</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">FP128</span>: <span class="id">P</span> <span class="id">TYPE_Fp128</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">PPC_FP128</span>: <span class="id">P</span> <span class="id">TYPE_Ppc_fp128</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">METADATA</span>: <span class="id">P</span> (<span class="id">TYPE_Metadata</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">X86_mmx</span>: <span class="id">P</span> (<span class="id">TYPE_X86_mmx</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">ARRAY</span>: <span class="kwd">forall</span> (<span class="id">sz</span>: <span class="id">int</span>) (<span class="id">t</span>: <span class="id">typ</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span> <span class="id">t</span> -&gt; <span class="id">P</span> (<span class="id">TYPE_Array</span> <span class="id">sz</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span>  <span class="id">FUNCTION</span>: <span class="kwd">forall</span> (<span class="id">ret</span>: <span class="id">typ</span>) (<span class="id">ts</span>: <span class="id">list</span> <span class="id">typ</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span> <span class="id">ret</span> -&gt; <span class="id">ForallListT</span> <span class="id">P</span> <span class="id">ts</span> -&gt; <span class="id">P</span> (<span class="id">TYPE_Function</span> <span class="id">ret</span> <span class="id">ts</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">STRUCT</span>: <span class="kwd">forall</span> (<span class="id">ts</span>: <span class="id">list</span> <span class="id">typ</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ForallListT</span> <span class="id">P</span> <span class="id">ts</span> -&gt; <span class="id">P</span> (<span class="id">TYPE_Struct</span> <span class="id">ts</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">PACKED</span>: <span class="kwd">forall</span> (<span class="id">ts</span>: <span class="id">list</span> <span class="id">typ</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ForallListT</span> <span class="id">P</span> <span class="id">ts</span> -&gt; <span class="id">P</span> (<span class="id">TYPE_Packed_struct</span> <span class="id">ts</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">OPAQUE</span>: <span class="id">P</span> (<span class="id">TYPE_Opaque</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">VECTOR</span>: <span class="kwd">forall</span> (<span class="id">sz</span>: <span class="id">int</span>) (<span class="id">t</span>: <span class="id">typ</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span> <span class="id">t</span> -&gt; <span class="id">P</span> (<span class="id">TYPE_Vector</span> <span class="id">sz</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Hypothesis</span> <span class="id">IDENTIFIED</span>: <span class="kwd">forall</span> (<span class="id">id</span>: <span class="id">ident</span>), <span class="id">P</span> (<span class="id">TYPE_Identified</span> <span class="id">id</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Check</span> (<span class="id">Forall_cons</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Check</span> (<span class="id">Forall</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Fixpoint</span> <span class="id">typ_nested_ind</span> (<span class="id">t</span>: <span class="id">typ</span>) : <span class="id">P</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">t</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_I</span> <span class="id">sz</span> =&gt; <span class="id">I</span> <span class="id">sz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Pointer</span> <span class="id">p</span> =&gt; <span class="id">POINTER</span> <span class="id">p</span> (<span class="id">typ_nested_ind</span> <span class="id">p</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Void</span> =&gt; <span class="id">VOID</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Half</span> =&gt; <span class="id">HALF</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Float</span> =&gt; <span class="id">FLOAT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Double</span> =&gt; <span class="id">DOUBLE</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_X86_fp80</span> =&gt; <span class="id">X86_fp80</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Fp128</span> =&gt; <span class="id">FP128</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Ppc_fp128</span> =&gt; <span class="id">PPC_FP128</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Metadata</span> =&gt; <span class="id">METADATA</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_X86_mmx</span> =&gt; <span class="id">X86_mmx</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Array</span> <span class="id">sz</span> <span class="id">t</span> =&gt; <span class="id">ARRAY</span> <span class="id">sz</span> <span class="id">t</span> (<span class="id">typ_nested_ind</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Function</span> <span class="id">ret</span> <span class="id">args</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">H</span> := (<span class="id">fix</span> <span class="id">fold</span> (<span class="id">xs</span>: <span class="id">list</span> <span class="id">typ</span>) : <span class="id">ForallListT</span> <span class="id">P</span> <span class="id">xs</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">xs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">ForallListT_nil</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">cons</span> <span class="id">x</span> <span class="id">xs</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ForallListT_cons</span> <span class="id">_</span> (<span class="id">typ_nested_ind</span> <span class="id">x</span>) (<span class="id">fold</span> <span class="id">xs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>) <span class="id">args</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">FUNCTION</span> <span class="id">ret</span> <span class="id">args</span> (<span class="id">typ_nested_ind</span> <span class="id">ret</span>) <span class="id">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Struct</span> <span class="id">ts</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">H</span> := (<span class="id">fix</span> <span class="id">fold</span> (<span class="id">xs</span>: <span class="id">list</span> <span class="id">typ</span>) : <span class="id">ForallListT</span> <span class="id">P</span> <span class="id">xs</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">xs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">ForallListT_nil</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">cons</span> <span class="id">x</span> <span class="id">xs</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ForallListT_cons</span> <span class="id">_</span> (<span class="id">typ_nested_ind</span> <span class="id">x</span>) (<span class="id">fold</span> <span class="id">xs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>) <span class="id">ts</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">STRUCT</span> <span class="id">ts</span> <span class="id">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Packed_struct</span> <span class="id">ts</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">H</span> := (<span class="id">fix</span> <span class="id">fold</span> (<span class="id">xs</span>: <span class="id">list</span> <span class="id">typ</span>) : <span class="id">ForallListT</span> <span class="id">P</span> <span class="id">xs</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">xs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">ForallListT_nil</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">cons</span> <span class="id">x</span> <span class="id">xs</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ForallListT_cons</span> <span class="id">_</span> (<span class="id">typ_nested_ind</span> <span class="id">x</span>) (<span class="id">fold</span> <span class="id">xs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>) <span class="id">ts</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">PACKED</span> <span class="id">ts</span> <span class="id">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Opaque</span> =&gt; <span class="id">OPAQUE</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Vector</span> <span class="id">sz</span> <span class="id">t</span> =&gt;  <span class="id">VECTOR</span> <span class="id">sz</span> <span class="id">t</span> (<span class="id">typ_nested_ind</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">TYPE_Identified</span> <span class="id">id</span> =&gt; <span class="id">IDENTIFIED</span> <span class="id">id</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<span class="kwd">End</span> <span class="id">typ_nested_ind</span>.<br/>
<span class="kwd">Check</span> (<span class="id">typ_nested_ind</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pointwise_decide_list_equality_to_list_equality</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">A</span>: <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">l1</span> <span class="id">l2</span>: <span class="id">list</span> <span class="id">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FORALL_DECEQ</span>: <span class="id">ForallListT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">t1</span> : <span class="id">A</span> =&gt; <span class="kwd">forall</span> <span class="id">t2</span> : <span class="id">A</span>, {<span class="id">t1</span> = <span class="id">t2</span>} + {<span class="id">t1</span> &lt;&gt; <span class="id">t2</span>}) <span class="id">l1</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">l1</span> = <span class="id">l2</span>} + {<span class="id">l1</span> &lt;&gt; <span class="id">l2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</div>
<div class="proofscript" id="proof6">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">l2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l1</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">l2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l2</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ADEC</span>: {<span class="id">a</span> = <span class="id">a0</span>} + {<span class="id">a</span> &lt;&gt; <span class="id">a0</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">FORALL_DECEQ</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">X</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LDEC</span>: {<span class="id">l1</span> = <span class="id">l2</span>} + {<span class="id">l1</span> &lt;&gt; <span class="id">l2</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">FORALL_DECEQ</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHl1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ADEC</span>; <span class="tactic">destruct</span> <span class="id">LDEC</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">type_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">t1</span> <span class="id">t2</span>: <span class="id">typ</span>), {<span class="id">t1</span> = <span class="id">t2</span>} + {<span class="id">t1</span> &lt;&gt; <span class="id">t2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</div>
<div class="proofscript" id="proof7">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">t1</span> <span class="kwd">using</span> <span class="id">typ_nested_ind</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>; <span class="tactic">destruct</span> <span class="id">t2</span>; <span class="tactic">auto</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">SZ_CASES</span>: {<span class="id">sz</span> = <span class="id">sz0</span>} + {<span class="id">sz</span> &lt;&gt; <span class="id">sz0</span>}); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SZ_CASES</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;- <span class="tactic">destruct</span> (<span class="id">IHt1</span> <span class="id">t2</span>); <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">SZ_CASES</span>: {<span class="id">sz</span> = <span class="id">sz0</span>} + {<span class="id">sz</span> &lt;&gt; <span class="id">sz0</span>}); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IHt1</span> <span class="id">t2</span>); <span class="tactic">destruct</span> <span class="id">SZ_CASES</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">T1_CASES</span>: {<span class="id">t1</span> = <span class="id">t2</span>} + {<span class="id">t1</span> &lt;&gt; <span class="id">t2</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHt1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LIST_EQ_CASES</span>: {<span class="id">ts</span> = <span class="id">args</span>} + {<span class="id">ts</span> &lt;&gt; <span class="id">args</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">pointwise_decide_list_equality_to_list_equality</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">T1_CASES</span>; <span class="tactic">destruct</span> <span class="id">LIST_EQ_CASES</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">LIST_EQ_CASES</span>: {<span class="id">ts</span> = <span class="id">fields</span>} + {<span class="id">ts</span> &lt;&gt; <span class="id">fields</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">pointwise_decide_list_equality_to_list_equality</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">LIST_EQ_CASES</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">LIST_EQ_CASES</span>: {<span class="id">ts</span> = <span class="id">fields</span>} + {<span class="id">ts</span> &lt;&gt; <span class="id">fields</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">pointwise_decide_list_equality_to_list_equality</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">LIST_EQ_CASES</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">SZ_CASES</span>: {<span class="id">sz</span> = <span class="id">sz0</span>} + {<span class="id">sz</span> &lt;&gt; <span class="id">sz0</span>}); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">T_CASES</span>: {<span class="id">t1</span> = <span class="id">t2</span>} + {<span class="id">t1</span> &lt;&gt; <span class="id">t2</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SZ_CASES</span>; <span class="tactic">destruct</span> <span class="id">T_CASES</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;- <span class="tactic">assert</span> (<span class="id">ID_EQ</span>: {<span class="id">id</span> = <span class="id">id0</span>} + {<span class="id">id</span> &lt;&gt; <span class="id">id0</span>}); <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ID_EQ</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">right</span>; <span class="tactic">intros</span> <span class="id">CONTRA</span>; <span class="tactic">inversion</span> <span class="id">CONTRA</span>; <span class="tactic">auto</span>; <span class="tactic">fail</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">type_eq_dec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">icmp</span> : <span class="kwd">Set</span> := <span class="id">Eq</span>|<span class="id">Ne</span>|<span class="id">Ugt</span>|<span class="id">Uge</span>|<span class="id">Ult</span>|<span class="id">Ule</span>|<span class="id">Sgt</span>|<span class="id">Sge</span>|<span class="id">Slt</span>|<span class="id">Sle</span>.<br/>
<span class="kwd">Inductive</span> <span class="id">fcmp</span> : <span class="kwd">Set</span> := <span class="id">FFalse</span>|<span class="id">FOeq</span>|<span class="id">FOgt</span>|<span class="id">FOge</span>|<span class="id">FOlt</span>|<span class="id">FOle</span>|<span class="id">FOne</span>|<span class="id">FOrd</span>|<span class="id">FUno</span>|<span class="id">FUeq</span>|<span class="id">FUgt</span>|<span class="id">FUge</span>|<span class="id">FUlt</span>|<span class="id">FUle</span>|<span class="id">FUne</span>|<span class="id">FTrue</span>.<br/>
<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">ibinop</span> : <span class="kwd">Set</span> :=<br/>
| <span class="kwd">Add</span> (<span class="id">nuw</span>:<span class="id">bool</span>) (<span class="id">nsw</span>:<span class="id">bool</span>)<br/>
| <span class="id">Sub</span> (<span class="id">nuw</span>:<span class="id">bool</span>) (<span class="id">nsw</span>:<span class="id">bool</span>)<br/>
| <span class="id">Mul</span> (<span class="id">nuw</span>:<span class="id">bool</span>) (<span class="id">nsw</span>:<span class="id">bool</span>)<br/>
| <span class="id">Shl</span> (<span class="id">nuw</span>:<span class="id">bool</span>) (<span class="id">nsw</span>:<span class="id">bool</span>)<br/>
| <span class="id">UDiv</span> (<span class="tactic">exact</span>:<span class="id">bool</span>)<br/>
| <span class="id">SDiv</span> (<span class="tactic">exact</span>:<span class="id">bool</span>)<br/>
| <span class="id">LShr</span> (<span class="tactic">exact</span>:<span class="id">bool</span>)<br/>
| <span class="id">AShr</span> (<span class="tactic">exact</span>:<span class="id">bool</span>)<br/>
| <span class="id">URem</span> | <span class="id">SRem</span> | <span class="id">And</span> | <span class="id">Or</span> | <span class="id">Xor</span><br/>
.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ibinop_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">ib1</span> <span class="id">ib2</span>: <span class="id">ibinop</span>), {<span class="id">ib1</span> = <span class="id">ib2</span>} + {<span class="id">ib1</span> &lt;&gt; <span class="id">ib2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</div>
<div class="proofscript" id="proof8">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">ibinop_eq_dec</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">fbinop</span> : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id">FAdd</span> | <span class="id">FSub</span> | <span class="id">FMul</span> | <span class="id">FDiv</span> | <span class="id">FRem</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fbinop_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">fb1</span> <span class="id">fb2</span>: <span class="id">fbinop</span>), {<span class="id">fb1</span> = <span class="id">fb2</span>} + {<span class="id">fb1</span> &lt;&gt; <span class="id">fb2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</div>
<div class="proofscript" id="proof9">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">fbinop_eq_dec</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">fast_math</span> : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id">Nnan</span> | <span class="id">Ninf</span> | <span class="id">Nsz</span> | <span class="id">Arcp</span> | <span class="id">Fast</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fast_math_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">fm1</span> <span class="id">fm2</span>: <span class="id">fast_math</span>), {<span class="id">fm1</span> = <span class="id">fm2</span>} + {<span class="id">fm1</span> &lt;&gt; <span class="id">fm2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</div>
<div class="proofscript" id="proof10">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">fast_math_eq_dec</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">conversion_type</span> : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id">Trunc</span> | <span class="id">Zext</span> | <span class="id">Sext</span> | <span class="id">Fptrunc</span> | <span class="id">Fpext</span> | <span class="id">Uitofp</span> | <span class="id">Sitofp</span> | <span class="id">Fptoui</span> |<br/>
&nbsp;&nbsp;<span class="id">Fptosi</span> | <span class="id">Inttoptr</span> | <span class="id">Ptrtoint</span> | <span class="id">Bitcast</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">conversion_type_eq_dec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c1</span> <span class="id">c2</span>: <span class="id">conversion_type</span>), {<span class="id">c1</span> = <span class="id">c2</span>} + {<span class="id">c1</span> &lt;&gt; <span class="id">c2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</div>
<div class="proofscript" id="proof11">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">conversion_type_eq_dec</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">tident</span> : <span class="kwd">Set</span> := (<span class="id">typ</span> * <span class="id">ident</span>)%<span class="id">type</span>.<br/>
<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">exp</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">EXP_Ident</span>   (<span class="id">id</span>:<span class="id">ident</span>)  <br/>
| <span class="id">EXP_Integer</span> (<span class="id">x</span>:<span class="id">int</span>)<br/>
| <span class="id">EXP_Float</span>   (<span class="id">f</span>:<span class="id">float</span>)<br/>
| <span class="id">EXP_Hex</span>     (<span class="id">f</span>:<span class="id">float</span>)  <br/>
| <span class="id">EXP_Bool</span>    (<span class="id">b</span>:<span class="id">bool</span>)<br/>
| <span class="id">EXP_Null</span><br/>
| <span class="id">EXP_Zero_initializer</span><br/>
| <span class="id">EXP_Cstring</span>         (<span class="id">s</span>:<span class="id">string</span>)<br/>
| <span class="id">EXP_Undef</span><br/>
| <span class="id">EXP_Struct</span>          (<span class="id">fields</span>: <span class="id">list</span> (<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">EXP_Packed_struct</span>   (<span class="id">fields</span>: <span class="id">list</span> (<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">EXP_Array</span>           (<span class="id">elts</span>: <span class="id">list</span> (<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">EXP_Vector</span>          (<span class="id">elts</span>: <span class="id">list</span> (<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">OP_IBinop</span>           (<span class="id">iop</span>:<span class="id">ibinop</span>) (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">v1</span>:<span class="id">exp</span>) (<span class="id">v2</span>:<span class="id">exp</span>)  <br/>
| <span class="id">OP_ICmp</span>             (<span class="id">cmp</span>:<span class="id">icmp</span>)   (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">v1</span>:<span class="id">exp</span>) (<span class="id">v2</span>:<span class="id">exp</span>)<br/>
| <span class="id">OP_FBinop</span>           (<span class="id">fop</span>:<span class="id">fbinop</span>) (<span class="id">fm</span>:<span class="id">list</span> <span class="id">fast_math</span>) (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">v1</span>:<span class="id">exp</span>) (<span class="id">v2</span>:<span class="id">exp</span>)<br/>
| <span class="id">OP_FCmp</span>             (<span class="id">cmp</span>:<span class="id">fcmp</span>)   (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">v1</span>:<span class="id">exp</span>) (<span class="id">v2</span>:<span class="id">exp</span>)<br/>
| <span class="id">OP_Conversion</span>       (<span class="id">conv</span>:<span class="id">conversion_type</span>) (<span class="id">t_from</span>:<span class="id">typ</span>) (<span class="id">v</span>:<span class="id">exp</span>) (<span class="id">t_to</span>:<span class="id">typ</span>)<br/>
| <span class="id">OP_GetElementPtr</span>    (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">ptrval</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">idxs</span>:<span class="id">list</span> (<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">OP_ExtractElement</span>   (<span class="id">vec</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">idx</span>:(<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">OP_InsertElement</span>    (<span class="id">vec</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">elt</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">idx</span>:(<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">OP_ShuffleVector</span>    (<span class="id">vec1</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">vec2</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">idxmask</span>:(<span class="id">typ</span> * <span class="id">exp</span>))<br/>
| <span class="id">OP_ExtractValue</span>     (<span class="id">vec</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">idxs</span>:<span class="id">list</span> <span class="id">int</span>)<br/>
| <span class="id">OP_InsertValue</span>      (<span class="id">vec</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">elt</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">idxs</span>:<span class="id">list</span> <span class="id">int</span>)<br/>
| <span class="id">OP_Select</span>           (<span class="id">cnd</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">v1</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) (<span class="id">v2</span>:(<span class="id">typ</span> * <span class="id">exp</span>)) <br/>
.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">exp_eq_dec</span> (<span class="id">e1</span> <span class="id">e2</span>: <span class="id">exp</span>): {<span class="id">e1</span> = <span class="id">e2</span>} + {<span class="id">e1</span> &lt;&gt; <span class="id">e2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</div>
<div class="proofscript" id="proof12">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>; <span class="tactic">do</span> 2 <span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">exp_eq_dec</span>.<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">texp</span> : <span class="kwd">Set</span> := <span class="id">typ</span> * <span class="id">exp</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">texp_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">te1</span> <span class="id">te2</span>: <span class="id">texp</span>), {<span class="id">te1</span> = <span class="id">te2</span>} + {<span class="id">te1</span> &lt;&gt; <span class="id">te2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</div>
<div class="proofscript" id="proof13">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">instr_id</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">IId</span>   (<span class="id">id</span>:<span class="id">raw_id</span>)    <br/>
| <span class="id">IVoid</span> (<span class="id">n</span>:<span class="id">int</span>)        <br/>
.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">instr_id_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">iid1</span> <span class="id">iid2</span>: <span class="id">instr_id</span>), {<span class="id">iid1</span> = <span class="id">iid2</span>} + {<span class="id">iid1</span> &lt;&gt; <span class="id">iid2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</div>
<div class="proofscript" id="proof14">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">instr_id_eq_dec</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">phi</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">Phi</span>  (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">args</span>:<span class="id">list</span> (<span class="id">block_id</span> * <span class="id">exp</span>))<br/>
.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="kwd">Inductive</span> <span class="id">instr</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">INSTR_Op</span>   (<span class="id">op</span>:<span class="id">exp</span>)                        <br/>
| <span class="id">INSTR_Call</span> (<span class="id">fn</span>:<span class="id">texp</span>) (<span class="id">args</span>:<span class="id">list</span> <span class="id">texp</span>)      <br/>
| <span class="id">INSTR_Alloca</span> (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">nb</span>: <span class="id">option</span> <span class="id">texp</span>) (<span class="id">align</span>:<span class="id">option</span> <span class="id">int</span>) <br/>
| <span class="id">INSTR_Load</span>  (<span class="id">volatile</span>:<span class="id">bool</span>) (<span class="id">t</span>:<span class="id">typ</span>) (<span class="id">ptr</span>:<span class="id">texp</span>) (<span class="id">align</span>:<span class="id">option</span> <span class="id">int</span>)       <br/>
| <span class="id">INSTR_Store</span> (<span class="id">volatile</span>:<span class="id">bool</span>) (<span class="id">val</span>:<span class="id">texp</span>) (<span class="id">ptr</span>:<span class="id">texp</span>) (<span class="id">align</span>:<span class="id">option</span> <span class="id">int</span>)<br/>
| <span class="id">INSTR_Fence</span><br/>
| <span class="id">INSTR_AtomicCmpXchg</span><br/>
| <span class="id">INSTR_AtomicRMW</span><br/>
| <span class="id">INSTR_Unreachable</span><br/>
| <span class="id">INSTR_VAArg</span><br/>
| <span class="id">INSTR_LandingPad</span><br/>
.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">instr_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">i1</span> <span class="id">i2</span>: <span class="id">instr</span>), {<span class="id">i1</span> = <span class="id">i2</span>} + {<span class="id">i1</span> &lt;&gt; <span class="id">i2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</div>
<div class="proofscript" id="proof15">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">instr_eq_dec</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">terminator</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">TERM_Ret</span>        (<span class="id">v</span>:<span class="id">texp</span>)<br/>
| <span class="id">TERM_Ret_void</span><br/>
| <span class="id">TERM_Br</span>         (<span class="id">v</span>:<span class="id">texp</span>) (<span class="id">br1</span>:<span class="id">block_id</span>) (<span class="id">br2</span>:<span class="id">block_id</span>) <br/>
| <span class="id">TERM_Br_1</span>       (<span class="id">br</span>:<span class="id">block_id</span>)<br/>
| <span class="id">TERM_Switch</span>     (<span class="id">v</span>:<span class="id">texp</span>) (<span class="id">default_dest</span>:<span class="id">block_id</span>) (<span class="id">brs</span>: <span class="id">list</span> (<span class="id">texp</span> * <span class="id">block_id</span>))<br/>
| <span class="id">TERM_IndirectBr</span> (<span class="id">v</span>:<span class="id">texp</span>) (<span class="id">brs</span>:<span class="id">list</span> <span class="id">block_id</span>) <br/>
| <span class="id">TERM_Resume</span>     (<span class="id">v</span>:<span class="id">texp</span>)<br/>
| <span class="id">TERM_Invoke</span>     (<span class="id">fnptrval</span>:<span class="id">tident</span>) (<span class="id">args</span>:<span class="id">list</span> <span class="id">texp</span>) (<span class="id">to_label</span>:<span class="id">block_id</span>) (<span class="id">unwind_label</span>:<span class="id">block_id</span>)<br/>
.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">terminator_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">t1</span> <span class="id">t2</span>: <span class="id">terminator</span>), {<span class="id">t1</span> = <span class="id">t2</span>} + {<span class="id">t1</span> &lt;&gt; <span class="id">t2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</div>
<div class="proofscript" id="proof16">
&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="id">decide</span> <span class="id">equality</span>).<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">terminator_eq_dec</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">thread_local_storage</span> : <span class="kwd">Set</span> :=<br/>
| <span class="id">TLS_Localdynamic</span><br/>
| <span class="id">TLS_Initialexec</span><br/>
| <span class="id">TLS_Localexec</span><br/>
.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">global</span> : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_global</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_ident</span>        : <span class="id">global_id</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_typ</span>          : <span class="id">typ</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_constant</span>     : <span class="id">bool</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_exp</span>          : <span class="id">option</span> <span class="id">exp</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_linkage</span>      : <span class="id">option</span> <span class="id">linkage</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_visibility</span>   : <span class="id">option</span> <span class="id">visibility</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_dll_storage</span>  : <span class="id">option</span> <span class="id">dll_storage</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_thread_local</span> : <span class="id">option</span> <span class="id">thread_local_storage</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_unnamed_addr</span> : <span class="id">bool</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_addrspace</span>    : <span class="id">option</span> <span class="id">int</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_externally_initialized</span>: <span class="id">bool</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_section</span>      : <span class="id">option</span> <span class="id">string</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">g_align</span>        : <span class="id">option</span> <span class="id">int</span>;<br/>
}.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">declaration</span> : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_declaration</span><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_name</span>        : <span class="id">function_id</span>;  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_type</span>        : <span class="id">typ</span>;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_param_attrs</span> : <span class="id">list</span> <span class="id">param_attr</span> * <span class="id">list</span> (<span class="id">list</span> <span class="id">param_attr</span>); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_linkage</span>     : <span class="id">option</span> <span class="id">linkage</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_visibility</span>  : <span class="id">option</span> <span class="id">visibility</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_dll_storage</span> : <span class="id">option</span> <span class="id">dll_storage</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_cconv</span>       : <span class="id">option</span> <span class="id">cconv</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_attrs</span>       : <span class="id">list</span> <span class="id">fn_attr</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_section</span>     : <span class="id">option</span> <span class="id">string</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_align</span>       : <span class="id">option</span> <span class="id">int</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dc_gc</span>          : <span class="id">option</span> <span class="id">string</span>;<br/>
&nbsp;&nbsp;}.<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">code</span> := <span class="id">list</span> (<span class="id">instr_id</span> * <span class="id">instr</span>).<br/>
<br/>
<span class="kwd">Record</span> <span class="id">block</span> : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_block</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">blk_id</span>    : <span class="id">block_id</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">blk_phis</span>  : <span class="id">list</span> (<span class="id">local_id</span> * <span class="id">phi</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">blk_code</span>  : <span class="id">code</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">blk_term</span>  : <span class="id">instr_id</span> * <span class="id">terminator</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">code_eq_dec</span>: <span class="kwd">forall</span> (<span class="id">c1</span> <span class="id">c2</span>: <span class="id">code</span>), {<span class="id">c1</span> = <span class="id">c2</span>} +  {<span class="id">c1</span> &lt;&gt; <span class="id">c2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</div>
<div class="proofscript" id="proof17">
&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="id">decide</span> <span class="id">equality</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">code_eq_dec</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">definition</span> (<span class="id">FnBody</span>:<span class="kwd">Set</span>) :=<br/>
&nbsp;&nbsp;<span class="id">mk_definition</span><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">df_prototype</span>   : <span class="id">declaration</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">df_args</span>        : <span class="id">list</span> <span class="id">local_id</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">df_instrs</span>      : <span class="id">FnBody</span>;<br/>
&nbsp;&nbsp;}.<br/>
<br/>
<span class="id">Arguments</span> <span class="id">df_prototype</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">df_args</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">df_instrs</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">metadata</span> : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id">METADATA_Const</span>  (<span class="id">tv</span>:<span class="id">texp</span>)<br/>
&nbsp;&nbsp;| <span class="id">METADATA_Null</span><br/>
&nbsp;&nbsp;| <span class="id">METADATA_Id</span>     (<span class="id">id</span>:<span class="id">raw_id</span>)  <br/>
&nbsp;&nbsp;| <span class="id">METADATA_String</span> (<span class="id">str</span>:<span class="id">string</span>)<br/>
&nbsp;&nbsp;| <span class="id">METADATA_Named</span>  (<span class="id">strs</span>:<span class="id">list</span> <span class="id">string</span>)<br/>
&nbsp;&nbsp;| <span class="id">METADATA_Node</span>   (<span class="id">mds</span>:<span class="id">list</span> <span class="id">metadata</span>)<br/>
.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">toplevel_entity</span> (<span class="id">FnBody</span>:<span class="kwd">Set</span>) : <span class="kwd">Set</span> :=<br/>
| <span class="id">TLE_Target</span>          (<span class="id">tgt</span>:<span class="id">string</span>)<br/>
| <span class="id">TLE_Datalayout</span>      (<span class="id">layout</span>:<span class="id">string</span>)<br/>
| <span class="id">TLE_Declaration</span>     (<span class="id">decl</span>:<span class="id">declaration</span>)<br/>
| <span class="id">TLE_Definition</span>      (<span class="id">defn</span>:<span class="id">definition</span> <span class="id">FnBody</span>)<br/>
| <span class="id">TLE_Type_decl</span>       (<span class="id">id</span>:<span class="id">ident</span>) (<span class="id">t</span>:<span class="id">typ</span>)<br/>
| <span class="id">TLE_Source_filename</span> (<span class="id">s</span>:<span class="id">string</span>)<br/>
| <span class="id">TLE_Global</span>          (<span class="id">g</span>:<span class="id">global</span>)<br/>
| <span class="id">TLE_Metadata</span>        (<span class="id">id</span>:<span class="id">raw_id</span>) (<span class="id">md</span>:<span class="id">metadata</span>)<br/>
| <span class="id">TLE_Attribute_group</span> (<span class="id">i</span>:<span class="id">int</span>) (<span class="id">attrs</span>:<span class="id">list</span> <span class="id">fn_attr</span>)<br/>
.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Target</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Datalayout</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Declaration</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Definition</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Type_decl</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Source_filename</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Global</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Metadata</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">TLE_Attribute_group</span> {<span class="id">_</span>} <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">toplevel_entities</span> (<span class="id">FnBody</span>:<span class="kwd">Set</span>) : <span class="kwd">Set</span> := <span class="id">list</span> (<span class="id">toplevel_entity</span> <span class="id">FnBody</span>).<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">typedefs</span> := <span class="id">list</span> (<span class="id">ident</span> * <span class="id">typ</span>).<br/>
<br/>
<span class="kwd">Record</span> <span class="id">modul</span> (<span class="id">FnBody</span>:<span class="kwd">Set</span>) : <span class="kwd">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_modul</span><br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_name</span>: <span class="id">option</span> <span class="id">string</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_target</span>: <span class="id">option</span> <span class="id">string</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_datalayout</span>: <span class="id">option</span> <span class="id">string</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_type_defs</span>: <span class="id">typedefs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_globals</span>: <span class="id">list</span> <span class="id">global</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_declarations</span>: <span class="id">list</span> <span class="id">declaration</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_definitions</span>: <span class="id">list</span> (<span class="id">definition</span> <span class="id">FnBody</span>);<br/>
&nbsp;&nbsp;}.<br/>
<br/>
<span class="id">Arguments</span> <span class="id">m_name</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">m_target</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">m_datalayout</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">m_type_defs</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">m_globals</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">m_declarations</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<span class="id">Arguments</span> <span class="id">m_definitions</span> {<span class="id">_</span>} <span class="id">_</span>.<br/>
<br/>
<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
