<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module ScopDefinition</title>
<meta name="description" content="Documentation of Coq module ScopDefinition" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module ScopDefinition</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Omega</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Nat</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ZArith</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Ring</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">List</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Ncring</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Ring_tac</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FunctionalExtensionality</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Maps</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Sorting</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ListSet</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Vellvm.Crush</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Vellvm.polyir.PolyIRUtil</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Vellvm.polyir.PolyIRDefinition</span>.<br/>
<br/>
<div class="doc">Import VPL for polyhedral goodness </div>
<span class="id">From</span> <span class="id">Vpl</span> <span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">PedraQ</span> <span class="id">DomainInterfaces</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">VplTactic.Tactic</span>.<br/>
<span class="kwd">Add</span> <span class="id">Field</span> <span class="id">Qcfield</span>: <span class="id">Qcft</span> (<span class="id">decidable</span> <span class="id">Qc_eq_bool_correct</span>, <span class="id">constants</span> [<span class="id">vpl_cte</span>]).<br/>
<br/>
<span class="kwd">Import</span> <span class="id">PedraQ.FullDom</span>.<br/>
<br/>
<span class="kwd">Local</span> <span class="kwd">Notation</span> "<span class="id">a</span> ## <span class="id">b</span>" := (<span class="id">ZMap.get</span> <span class="id">b</span> <span class="id">a</span>) (<span class="tactic">at</span> <span class="id">level</span> 1).<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">EquivDec</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Equalities</span>.<br/>
<br/>
<span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">list_scope</span>.<br/>
<span class="kwd">Import</span> <span class="id">ListNotations</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">option_traverse</span> {<span class="id">A</span>: <span class="kwd">Type</span>} (<span class="id">lo</span>: <span class="id">list</span> (<span class="id">option</span> <span class="id">A</span>)): <span class="id">option</span> (<span class="id">list</span> <span class="id">A</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">lo</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [] =&gt; <span class="id">Some</span> []<br/>
&nbsp;&nbsp;| <span class="id">oa</span>::<span class="id">lo</span>' =&gt; <span class="id">oa</span> &gt;&gt;= (<span class="kwd">fun</span> <span class="id">a</span> =&gt; <span class="id">option_map</span> (<span class="id">cons</span> <span class="id">a</span>) (<span class="id">option_traverse</span> <span class="id">lo</span>'))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">option_traverse_fold_left</span> {<span class="id">ACCUM</span> <span class="id">A</span>: <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accum</span>: <span class="id">ACCUM</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f</span>: <span class="id">ACCUM</span> -&gt; <span class="id">A</span> -&gt; <span class="id">option</span> <span class="id">ACCUM</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">l</span>: <span class="id">list</span> <span class="id">A</span>): <span class="id">option</span> (<span class="id">ACCUM</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [] =&gt; <span class="id">Some</span> <span class="id">accum</span><br/>
&nbsp;&nbsp;| <span class="id">a</span>::<span class="id">l</span>' =&gt; (<span class="id">f</span> <span class="id">accum</span> <span class="id">a</span>) &gt;&gt;= (<span class="kwd">fun</span> <span class="id">accum2</span> =&gt; <span class="id">option_traverse_fold_left</span> <span class="id">accum2</span> <span class="id">f</span> <span class="id">l</span>')<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<h3>Consider making IX a type </h3>
<span class="kwd">Lemma</span> <span class="id">ix_eq_decidable</span>: <span class="kwd">forall</span> (<span class="id">ix1</span> <span class="id">ix2</span>: <span class="id">list</span> <span class="id">Z</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">ix1</span> = <span class="id">ix2</span>} + {<span class="id">ix1</span> &lt;&gt; <span class="id">ix2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</div>
<div class="proofscript" id="proof1">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">ix_eq_decidable</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="kwd">Type</span> <span class="id">POLYHEDRAL_THEORY</span>.<br/>
<div class="doc">A point in a polyhedra </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">PointT</span>: <span class="kwd">Type</span>.<br/>
<div class="doc">A polyhedra </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">PolyT</span>: <span class="kwd">Type</span>.<br/>
<div class="doc">Affine function </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">AffineFnT</span>: <span class="kwd">Type</span>.<br/>
<div class="doc">Affine relation </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">AffineRelT</span>: <span class="kwd">Type</span>.<br/>
<div class="doc">Paramter values, which allows to instantiate a parametric
      polyhedra into a concrete polyhedra </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">ParamsT</span>: <span class="kwd">Type</span>.<br/>
<div class="doc">Some way to specify a dimension </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">DimensionT</span>: <span class="kwd">Type</span>.<br/>
<div class="doc">Some way to map a point with an affine function </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">mapPoint</span>: <span class="id">AffineFnT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">option</span> (<span class="id">PointT</span>).<br/>
<div class="doc">Has some way to fill in the free variables </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">evalPoint</span>: <span class="id">ParamsT</span> -&gt; <span class="id">PointT</span> -&gt; (<span class="id">list</span> <span class="id">Z</span>).<br/>
<br/>
<div class="doc">Convert a point x0 to a polyhedra {x | x = x0 } </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">pointToPoly</span>: <span class="id">PointT</span> -&gt; <span class="id">PolyT</span>.<br/>
<br/>
<div class="doc">Compose an affine function </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">composeAffineFunction</span>: <span class="id">AffineFnT</span> -&gt; <span class="id">AffineFnT</span> -&gt; <span class="id">AffineFnT</span>.<br/>
<br/>
<div class="doc">Find the inverse of a concrete evaluation of an affine function *</div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">invertEvalAffineFn</span>: <span class="id">ParamsT</span> -&gt; <span class="id">AffineFnT</span> -&gt; <span class="id">list</span> <span class="id">Z</span> -&gt; <span class="id">PointT</span>.<br/>
<br/>
<div class="doc">Evaluate an affine function </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">evalAffineFn</span>: <span class="id">ParamsT</span> -&gt; <span class="id">AffineFnT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">list</span> <span class="id">Z</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">invertEvalAffineFn_is_inverse</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pt</span>: <span class="id">PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fn</span>: <span class="id">AffineFnT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">invertEvalAffineFn</span> <span class="id">params</span> <span class="id">fn</span> (<span class="id">evalAffineFn</span> <span class="id">params</span> <span class="id">fn</span> <span class="id">pt</span>) = <span class="id">pt</span>.<br/>
&nbsp;&nbsp;<br/>
<div class="doc">Have some way to check if two points are related </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">arePointsRelated</span>: <span class="id">PointT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">AffineRelT</span> -&gt; <span class="id">bool</span>.<br/>
<div class="doc">Check if a point is within a polyhedra </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">isPointInPoly</span>: <span class="id">PointT</span> -&gt; <span class="id">PolyT</span> -&gt; <span class="id">bool</span>.<br/>
<br/>
<div class="doc">x \in { x0 } -&gt; x = x0 </div>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">pointInSingletonPoly</span>: <span class="kwd">forall</span> (<span class="id">p</span>: <span class="id">PointT</span>) (<span class="id">singleton</span>: <span class="id">PointT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPointInPoly</span> <span class="id">p</span> (<span class="id">pointToPoly</span> <span class="id">singleton</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span> = <span class="id">singleton</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">pointInSubsetPoly</span>: <span class="kwd">forall</span> (<span class="id">p</span>: <span class="id">PointT</span>) (<span class="id">smaller</span> <span class="id">larger</span>: <span class="id">PolyT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPointInPoly</span> <span class="id">p</span> <span class="id">smaller</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPointInPoly</span> <span class="id">p</span> <span class="id">larger</span> = <span class="id">true</span>.<br/>
<br/>
<br/>
<div class="doc">isPolySubset P Q = is P a subset of Q </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">isPolySubset</span>: <span class="id">PolyT</span> -&gt; <span class="id">PolyT</span> -&gt; <span class="id">bool</span>.<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<br/>
<div class="doc">Returns whether one point is lex &lt; than the other </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">isLexLT</span>: <span class="id">PointT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">option</span> (<span class="id">bool</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Notation</span> "<span class="id">p</span> &lt;<span class="id">l</span> <span class="id">q</span>" := (<span class="id">isLexLT</span> <span class="id">p</span> <span class="id">q</span>) (<span class="tactic">at</span> <span class="id">level</span> 50).<br/>
<br/>
&nbsp;&nbsp;<br/>
<div class="doc">Returns whether one point is lex &gt; than the other </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">isLexGT</span>: <span class="id">PointT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">option</span> (<span class="id">bool</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Notation</span> "<span class="id">p</span> &gt;<span class="id">l</span> <span class="id">q</span>" := (<span class="id">isLexGT</span> <span class="id">p</span> <span class="id">q</span>) (<span class="tactic">at</span> <span class="id">level</span> 50).<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">isLexLT_GT</span>: <span class="kwd">forall</span> (<span class="id">a</span> <span class="id">b</span> :<span class="id">PointT</span>), <span class="id">isLexLT</span> <span class="id">a</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&gt; <span class="id">isLexGT</span> <span class="id">b</span> <span class="id">a</span> = <span class="id">Some</span> <span class="id">true</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">isLexGT_not_refl</span>: <span class="kwd">forall</span> (<span class="id">p</span>: <span class="id">PointT</span>), <span class="id">isLexGT</span> <span class="id">p</span> <span class="id">p</span> = <span class="id">Some</span> <span class="id">false</span>.<br/>
<br/>
<br/>
<div class="doc">Returns whether one point is lex smaller than the other </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getLexminPoint</span>: <span class="id">ParamsT</span> -&gt; <span class="id">PolyT</span> -&gt; <span class="id">PointT</span>.<br/>
<br/>
<div class="doc">Returns whether one point is lex smaller than the other </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getLexmaxPoint</span>: <span class="id">ParamsT</span> -&gt; <span class="id">PolyT</span> -&gt; <span class="id">PointT</span>.<br/>
&nbsp;&nbsp;<br/>
<div class="doc">Find the next point that is within the polyhedra which is
    one smaller in terms of lex order. return Nothing if not possible </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getPrevLexPoint</span>:<span class="id">ParamsT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PolyT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PointT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">option</span> (<span class="id">PointT</span>).<br/>
<br/>
<br/>
<div class="doc">Find the next point that is within the polyhedra which is
    one larger in terms of lex order. return Nothing if not possible </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getLexNextPoint</span>: <span class="id">ParamsT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PolyT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PointT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">option</span> (<span class="id">PointT</span>).<br/>
<br/>
<br/>
<div class="doc">Get the polyhedra of points which are lex &lt;=  the given point </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getLexLeqPoly</span>: <span class="id">ParamsT</span> -&gt; <span class="id">PolyT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">PolyT</span>.<br/>
<br/>
<div class="doc">Get the polyhedra of points which are lex &lt;  the given point </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getLexLtPoly</span>: <span class="id">ParamsT</span> -&gt; <span class="id">PolyT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">PolyT</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">getLexLeqPoly_proper_wrt_subset</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">small</span> <span class="id">large</span>: <span class="id">PolyT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">p</span>: <span class="id">PointT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPolySubset</span> <span class="id">small</span> <span class="id">large</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPolySubset</span> (<span class="id">getLexLeqPoly</span> <span class="id">params</span> <span class="id">small</span> <span class="id">p</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getLexLeqPoly</span> <span class="id">params</span> <span class="id">large</span> <span class="id">p</span>) = <span class="id">true</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">getLexLeqPoly_contains_leq_point</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">poly</span>: <span class="id">PolyT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">p</span>: <span class="id">PointT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPointInPoly</span> <span class="id">p</span> <span class="id">poly</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPointInPoly</span> <span class="id">p</span> (<span class="id">getLexLeqPoly</span> <span class="id">params</span> <span class="id">poly</span> <span class="id">p</span>) = <span class="id">true</span>.<br/>
<br/>
<div class="doc">{x | x &lt;= lexmin(P), x \in P} = { lexmin(P)} </div>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">getLexLeqPoly_from_lexmin_is_point</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">poly</span>: <span class="id">PolyT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getLexLeqPoly</span> <span class="id">params</span> <span class="id">poly</span> (<span class="id">getLexminPoint</span> <span class="id">params</span> <span class="id">poly</span>)) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pointToPoly</span> (<span class="id">getLexminPoint</span> <span class="id">params</span> <span class="id">poly</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<div class="doc">Get the polyhedra of points which are lex &gt; the given point </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getLexGtPoly</span>: <span class="id">ParamsT</span> -&gt; <span class="id">PolyT</span> -&gt; <span class="id">PointT</span> -&gt; <span class="id">PolyT</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getOverapproximationNumPointsInPoly</span>: <span class="id">ParamsT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PolyT</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">option</span> (<span class="id">nat</span>).<br/>
<div class="doc">Definition of an empty polyhedra </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">emptyPoly</span>: <span class="id">PolyT</span>.<br/>
<br/>
<div class="doc">Empty affine relation </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">emptyAffineRel</span>: <span class="id">AffineRelT</span>.<br/>
<br/>
<div class="doc">Take a union of two relations </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">unionAffineRel</span>:  <span class="id">AffineRelT</span> -&gt; <span class="id">AffineRelT</span> -&gt; <span class="id">AffineRelT</span>.<br/>
<br/>
<div class="doc">Weaken an affine function into an affine relation </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">affineFnToAffineRel</span>: <span class="id">AffineFnT</span> -&gt; <span class="id">AffineRelT</span>.<br/>
<br/>
<br/>
<div class="doc">Definition of union of polyhedra </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">unionPoly</span>:  <span class="id">PolyT</span> -&gt; <span class="id">PolyT</span> -&gt;  <span class="id">PolyT</span>.<br/>
&nbsp;&nbsp;<br/>
<div class="doc">unionPoly is commutative </div>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">unionPoly_commutative</span>: <span class="kwd">forall</span> (<span class="id">p</span> <span class="id">q</span>: <span class="id">PolyT</span>), <span class="id">unionPoly</span> <span class="id">p</span> <span class="id">q</span> = <span class="id">unionPoly</span> <span class="id">q</span> <span class="id">p</span>.<br/>
<br/>
&nbsp;&nbsp;<br/>
<div class="doc">unionPoly is associative </div>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">unionPoly_associative</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">p</span> <span class="id">q</span> <span class="id">r</span>: <span class="id">PolyT</span>), <span class="id">unionPoly</span> <span class="id">p</span> (<span class="id">unionPoly</span> <span class="id">q</span> <span class="id">r</span>) = <span class="id">unionPoly</span> (<span class="id">unionPoly</span> <span class="id">p</span> <span class="id">q</span>) <span class="id">r</span>.<br/>
<br/>
&nbsp;&nbsp;<br/>
<div class="doc">A polyhedra is always a subset of the union </div>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">subset_of_union</span>: <span class="kwd">forall</span> (<span class="id">P</span> <span class="id">Q</span>: <span class="id">PolyT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPolySubset</span> <span class="id">P</span> (<span class="id">unionPoly</span> <span class="id">P</span> <span class="id">Q</span>) = <span class="id">true</span>.<br/>
<br/>
<br/>
<div class="doc">Defines what it means to be a dependence relation. This is the
        over-approximate definition. In particular, it does not ask for
        exact dependence relations .
<pre>
        t1 --R1--&gt; p 
        t2 --R2--&gt; p
        t1 &lt; t2
        ===============
          t1 --D--&gt; t2</pre>
   </div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">relationIsDependenceBetweenRelations</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">r1</span> <span class="id">r2</span>: <span class="id">AffineRelT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">dep</span>: <span class="id">AffineRelT</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">tp1</span> <span class="id">tp2</span> <span class="id">ixp1</span> <span class="id">ixp2</span>: <span class="id">PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TP1_MAPSTO_IXP1</span>: <span class="id">arePointsRelated</span>  <span class="id">tp1</span> <span class="id">ixp1</span> <span class="id">r1</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TP2_MAPSTO_IXP2</span>: <span class="id">arePointsRelated</span> <span class="id">tp2</span> <span class="id">ixp2</span> <span class="id">r2</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">IXEQ</span>: <span class="id">ixp1</span> = <span class="id">ixp2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TP_LEX_ORDERED</span>: <span class="id">isLexLT</span> <span class="id">tp1</span> <span class="id">tp2</span> = <span class="id">Some</span> <span class="id">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">arePointsRelated</span> <span class="id">tp1</span> <span class="id">tp2</span> <span class="id">dep</span> = <span class="id">true</span>.<br/>
<br/>
<div class="doc">A function to compute the dependence polyhedra of two relations </div>
&nbsp;&nbsp;<span class="kwd">Parameter</span> <span class="id">getDependenceRelation</span>: <span class="id">AffineRelT</span> -&gt; <span class="id">AffineRelT</span> -&gt; <span class="id">option</span> <span class="id">AffineRelT</span>.<br/>
<br/>
<br/>
<div class="doc">An induction principle on all points that are lex smaller tha a
  given point in the polyhedra </div>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">polyhedra_ind_lex_smaller_points</span>: <span class="kwd">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span>: <span class="id">PointT</span> -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Q</span>: <span class="id">PolyT</span> -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fullpoly</span>: <span class="id">PolyT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Q</span> <span class="id">emptyPoly</span>) -&gt; (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">curpoint</span>: <span class="id">PointT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Q</span> (<span class="id">getLexLtPoly</span> <span class="id">params</span> <span class="id">fullpoly</span> <span class="id">curpoint</span>) -&gt; <span class="id">P</span> <span class="id">curpoint</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Q</span> (<span class="id">getLexLeqPoly</span> <span class="id">params</span> <span class="id">fullpoly</span> <span class="id">curpoint</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Q</span> <span class="id">fullpoly</span>.<br/>
<br/>
&nbsp;&nbsp;<br/>
<div class="doc">The lex min point is not lex greater than any point </div>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">isLexGT_of_lexmin_is_always_false</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">ParamsT</span>) (<span class="id">poly</span>: <span class="id">PolyT</span>) (<span class="id">pt</span>: <span class="id">PointT</span>) (<span class="id">b</span>: <span class="id">bool</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isPointInPoly</span> <span class="id">pt</span> <span class="id">poly</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isLexGT</span> (<span class="id">getLexminPoint</span> <span class="id">params</span> <span class="id">poly</span>) <span class="id">pt</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">b</span> = <span class="id">false</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">isLexLT_next_implies_isLexLEQ_current</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">dom</span>: <span class="id">PolyT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">next</span> <span class="id">cur</span> <span class="id">p</span>: <span class="id">PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NEXT</span>: <span class="id">getLexNextPoint</span> <span class="id">params</span> <span class="id">dom</span> <span class="id">cur</span> = <span class="id">Some</span> <span class="id">next</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LT</span>: <span class="id">p</span> &lt;<span class="id">l</span> <span class="id">next</span> = <span class="id">Some</span> <span class="id">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span> &lt;<span class="id">l</span> <span class="id">cur</span> = <span class="id">Some</span> <span class="id">true</span> \/ <span class="id">p</span> = <span class="id">cur</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<br/>
<span class="kwd">End</span> <span class="id">POLYHEDRAL_THEORY</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">SCOP</span>(<span class="id">P</span>: <span class="id">POLYHEDRAL_THEORY</span>).<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">AccessFunction</span> := <span class="id">P.AffineFnT</span>. <span class="docright">(* Access function to model where to read or write from  *)</span><br/>
<br/>
&nbsp;&nbsp;<br/>
<div class="doc">The identifier of some loaded value, to be stored in the abstract
    scop environment </div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">ScopLoadIdent</span> := <span class="id">Z</span>.<br/>
<br/>
<div class="doc">Mapping from load identifiers to values </div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">ScopEnvironment</span> := <span class="id">ZMap.t</span> (<span class="id">option</span> <span class="id">Z</span>).<br/>
<br/>
<div class="doc">The things that a store expression is allowed to store
   A<span class="bracket"><span class="id">i</span>, <span class="id">j</span>, <span class="id">k</span>, ..</span> = &lt;ScopStore&gt;</div>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">ScopStoreValue</span> :=<br/>
&nbsp;&nbsp;| <span class="id">SSVIndvarFn</span> (<span class="id">indvarfn</span>: <span class="id">list</span> <span class="id">Z</span> -&gt; <span class="id">Z</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ScopStoreValue</span> <span class="docright">(* function of indvars  *)</span><br/>
&nbsp;&nbsp;| <span class="id">SSVLoadedVal</span> (<span class="id">itostore</span>: <span class="id">ScopLoadIdent</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ScopStoreValue</span> <span class="docright">(* store some loaded value  *)</span><br/>
&nbsp;&nbsp;.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">MemoryAccess</span> :=<br/>
&nbsp;&nbsp;| <span class="id">MAStore</span> (<span class="id">chunk</span>: <span class="id">ChunkNum</span>) <span class="docright">(* array name  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">AccessFunction</span>) <span class="docright">(* index expression  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ssv</span>: <span class="id">ScopStoreValue</span>) <span class="docright">(* value to store  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id">MemoryAccess</span><br/>
&nbsp;&nbsp;| <span class="id">MALoad</span> (<span class="id">chunk</span>: <span class="id">ChunkNum</span>) <span class="docright">(* name  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">loadname</span>: <span class="id">ScopLoadIdent</span>)  <span class="docright">(* abstract store identiffier  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">AccessFunction</span>) <span class="docright">(* index expression  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id">MemoryAccess</span>.<br/>
<br/>
<h2>Return the access function of this array </h2>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getMAAccessFunction</span> (<span class="id">ma</span>: <span class="id">MemoryAccess</span>): <span class="id">AccessFunction</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ma</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MAStore</span> <span class="id">_</span> <span class="id">accessfn</span> <span class="id">_</span> =&gt; <span class="id">accessfn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MALoad</span> <span class="id">_</span> <span class="id">_</span> <span class="id">accessfn</span> =&gt; <span class="id">accessfn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<div class="doc">Space where the virtual induction variables live *</div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">VIVSpace</span> := <span class="id">P.PolyT</span>.<br/>
<div class="doc">Space where the multidimensional timepoints live </div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">ScatterSpace</span> := <span class="id">P.PolyT</span>.<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">ScopStmt</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkScopStmt</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmtDomain</span>: <span class="id">VIVSpace</span>; <span class="docright">(* Stmt is executed if `viv \in scopStmtDomain`  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmtSchedule</span> : <span class="id">P.AffineFnT</span>; <span class="docright">(* `VIVSpace -&gt; ScatterSpace`  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmtMemAccesses</span>: <span class="id">list</span> <span class="id">MemoryAccess</span> <span class="docright">(* List of memory accesses  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">Scop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkScop</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmts</span> : <span class="id">list</span> <span class="id">ScopStmt</span>; <span class="docright">(* The statements in this scop  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>
<br/>
<div class="doc">Get the memory accesses in a scop </div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getScopMemoryAccesses</span> (<span class="id">scop</span>: <span class="id">Scop</span>): <span class="id">list</span> <span class="id">MemoryAccess</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">concat</span> (<span class="id">List.map</span> (<span class="id">scopStmtMemAccesses</span>) (<span class="id">scopStmts</span> <span class="id">scop</span>)).<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">evalAccessFunction</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">P.AffineFnT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span> : <span class="id">P.PointT</span>) : (<span class="id">list</span> <span class="id">Z</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.evalAffineFn</span> <span class="id">params</span>  <span class="id">accessfn</span> <span class="id">viv</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">evalAccessFunction</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Transparent</span>  <span class="id">evalAccessFunction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getMemAccessLoadRelation</span> (<span class="id">ma</span>: <span class="id">MemoryAccess</span>) : <span class="id">P.AffineRelT</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ma</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MALoad</span> <span class="id">_</span> <span class="id">_</span> <span class="id">accessfn</span> =&gt; <span class="id">P.affineFnToAffineRel</span> <span class="id">accessfn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>  =&gt;  <span class="id">P.emptyAffineRel</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span> .<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getMemAccessStoreRelation</span> (<span class="id">ma</span>: <span class="id">MemoryAccess</span>) : <span class="id">P.AffineRelT</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ma</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MAStore</span> <span class="id">_</span> <span class="id">accessfn</span> <span class="id">_</span> =&gt; <span class="id">P.affineFnToAffineRel</span> <span class="id">accessfn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>=&gt;  <span class="id">P.emptyAffineRel</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span> .<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getScopStmtLoads</span> (<span class="id">ss</span>: <span class="id">ScopStmt</span>): <span class="id">P.AffineRelT</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span> <span class="id">P.unionAffineRel</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">List.map</span> <span class="id">getMemAccessLoadRelation</span>  (<span class="id">scopStmtMemAccesses</span> <span class="id">ss</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.emptyAffineRel</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getScopStmtStores</span> (<span class="id">ss</span>: <span class="id">ScopStmt</span>): <span class="id">P.AffineRelT</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span> <span class="id">P.unionAffineRel</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">List.map</span> <span class="id">getMemAccessStoreRelation</span>  (<span class="id">scopStmtMemAccesses</span> <span class="id">ss</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.emptyAffineRel</span>.<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getScopStores</span>(<span class="id">s</span>: <span class="id">Scop</span>): <span class="id">P.AffineRelT</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span> (<span class="kwd">fun</span> <span class="id">rel</span> <span class="id">ss</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.unionAffineRel</span> <span class="id">rel</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopStmtStores</span> <span class="id">ss</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmts</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.emptyAffineRel</span>.<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getScopLoads</span>(<span class="id">s</span>: <span class="id">Scop</span>): <span class="id">P.AffineRelT</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span> (<span class="kwd">fun</span> <span class="id">rel</span> <span class="id">ss</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.unionAffineRel</span> <span class="id">rel</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopStmtLoads</span> <span class="id">ss</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmts</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.emptyAffineRel</span>.<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">scheduleRespectsDependence</span> (<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">dep</span>: <span class="id">P.AffineRelT</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">p1</span> <span class="id">q1</span>: <span class="id">P.PointT</span>), (<span class="id">P.arePointsRelated</span> <span class="id">p1</span> <span class="id">q1</span> <span class="id">dep</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">p2</span> <span class="id">q2</span>: <span class="id">P.PointT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.mapPoint</span> <span class="id">schedule</span> <span class="id">p1</span> = <span class="id">Some</span> <span class="id">q1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.mapPoint</span> <span class="id">schedule</span> <span class="id">p2</span> = <span class="id">Some</span> <span class="id">q2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.arePointsRelated</span> (<span class="id">q1</span>) (<span class="id">q2</span>) <span class="id">dep</span> = <span class="id">true</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">scheduleRespectsRAW</span> (<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>) (<span class="id">s</span>: <span class="id">Scop</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rel</span>: <span class="id">P.AffineRelT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getDependenceRelation</span> (<span class="id">getScopStores</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopLoads</span> <span class="id">s</span>) = <span class="id">Some</span> <span class="id">rel</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependence</span> <span class="id">schedule</span> <span class="id">rel</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">scheduleRespectsWAW</span> (<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>) (<span class="id">s</span>: <span class="id">Scop</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rel</span>: <span class="id">P.AffineRelT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getDependenceRelation</span> (<span class="id">getScopStores</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopStores</span> <span class="id">s</span>) = <span class="id">Some</span> <span class="id">rel</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependence</span> <span class="id">schedule</span> <span class="id">rel</span>.<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">applyScheduleToScopStmt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ss</span>: <span class="id">ScopStmt</span>):  <span class="id">ScopStmt</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmtDomain</span> := <span class="id">scopStmtDomain</span> <span class="id">ss</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmtSchedule</span> := <span class="id">P.composeAffineFunction</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmtSchedule</span> <span class="id">ss</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">schedule</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmtMemAccesses</span> := <span class="id">scopStmtMemAccesses</span> <span class="id">ss</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">applyScheduleToScop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>): <span class="id">Scop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmts</span> := <span class="id">List.map</span> (<span class="id">applyScheduleToScopStmt</span> <span class="id">schedule</span>) (<span class="id">scopStmts</span> <span class="id">scop</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>
<br/>
&nbsp;&nbsp;<br/>
<h1>Hint database of proof </h1>
&nbsp;&nbsp;<span class="id">Create</span> <span class="id">HintDb</span> <span class="id">proofdb</span>.<br/>
<br/>
<h2>Add all theorems from the polyhedral theory  into hint database</h2>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.invertEvalAffineFn_is_inverse</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.isLexLT_GT</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">P.isLexLT_GT</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.unionPoly_commutative</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.unionPoly_associative</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.getLexLeqPoly_proper_wrt_subset</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.subset_of_union</span>:<span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.getLexLeqPoly_from_lexmin_is_point</span>:<span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.getLexLeqPoly_contains_leq_point</span>:<span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.pointInSingletonPoly</span>:<span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.isLexGT_not_refl</span>:<span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">P.isLexLT_next_implies_isLexLEQ_current</span>:<span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">Z.eqb_refl</span>: <span class="id">proofdb</span>.<br/>
<br/>
<div class="doc">List rewrite rules </div>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">existsb_app_single</span>: <span class="kwd">forall</span> {<span class="id">A</span>: <span class="kwd">Type</span>} (<span class="id">l</span>: <span class="id">list</span> <span class="id">A</span>) (<span class="id">a</span>: <span class="id">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pred</span>: <span class="id">A</span> -&gt; <span class="id">bool</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">existsb</span> <span class="id">pred</span> (<span class="id">l</span> ++ [<span class="id">a</span>]) = <span class="id">existsb</span> <span class="id">pred</span> <span class="id">l</span> || <span class="id">pred</span> <span class="id">a</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</div>
<div class="proofscript" id="proof2">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">existsb_app</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">orb_false_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> @<span class="id">existsb_app_single</span>: <span class="id">list</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">existsb_app</span>: <span class="id">list</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">existsb_app</span>: <span class="id">list</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">orb_false_elim</span>: <span class="id">list</span>.<br/>
<br/>
<h1>Section that define the semantics of scop evaluation </h1>
&nbsp;&nbsp;<span class="kwd">Section</span> <span class="id">EVALUATION</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">viv</span> := <span class="id">P.PointT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">Schedule</span> := <span class="id">P.AffineFnT</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">exec_scop_store_value</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.ParamsT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ScopEnvironment</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ScopStoreValue</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Value</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">eval_ssv_indvar_fn</span>: <span class="kwd">forall</span> (<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">evalviv</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EVALVIV</span>: <span class="id">P.evalPoint</span> <span class="id">params</span> <span class="id">viv</span> = <span class="id">evalviv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">indvarfn</span>: <span class="id">list</span> <span class="id">Z</span> -&gt; <span class="id">Z</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_store_value</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SSVIndvarFn</span> <span class="id">indvarfn</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">indvarfn</span> <span class="id">evalviv</span>)<br/>
&nbsp;&nbsp;| <span class="id">eval_ssv_loaded_value</span>: <span class="kwd">forall</span> (<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ident</span>: <span class="id">ScopLoadIdent</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">identval</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SE_AT_IDENT</span>: <span class="id">se</span> ## <span class="id">ident</span> = <span class="id">Some</span> <span class="id">identval</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_store_value</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SSVLoadedVal</span> <span class="id">ident</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">identval</span><br/>
&nbsp;&nbsp;.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">exec_scop_store_value_deterministic</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">v1</span> <span class="id">v2</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC1</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">ssv</span> <span class="id">v1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC2</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">ssv</span> <span class="id">v2</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">v1</span> = <span class="id">v2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</div>
<div class="proofscript" id="proof3">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXEC1</span>; <span class="tactic">subst</span>; <span class="tactic">inversion</span> <span class="id">EXEC2</span>; <span class="tactic">subst</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">exec_scop_store_value_deterministic</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">exec_memory_access</span>:  <span class="id">P.ParamsT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ScopEnvironment</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">MemoryAccess</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_store</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessix</span>: <span class="id">list</span> <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ACCESSIX</span>: <span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv</span> = <span class="id">accessix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">storeval</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SSV</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">ssv</span> <span class="id">storeval</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_memory_access</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">initmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">storeMemory</span> <span class="id">chunk</span> <span class="id">accessix</span> <span class="id">storeval</span> <span class="id">initmem</span>).<br/>
<br/>
<div class="doc">Evaluate a scop statement schedule to get the timepoint in the scatterspace </div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">evalScopStmtSchedule</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>) (<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stmt</span>: <span class="id">ScopStmt</span>) : <span class="id">list</span> <span class="id">Z</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.evalAffineFn</span> <span class="id">params</span> (<span class="id">scopStmtSchedule</span> <span class="id">stmt</span>) <span class="id">viv</span>.<br/>
<br/>
<br/>
<br/>
<div class="doc">Execute a statement. Checks if the statement is active or inactive before
       execution </div>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">exec_scop_stmt</span>: <span class="id">P.ParamsT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ScopEnvironment</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ScopStmt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_stmt_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">P.PolyT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> (<span class="id">mkScopStmt</span> <span class="id">domain</span> <span class="id">schedule</span> []) <span class="id">initmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_stmt_cons_active</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">P.PolyT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PT_IN_DOMAIN</span>: <span class="id">P.isPointInPoly</span> <span class="id">viv</span> <span class="id">domain</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mas</span>: <span class="id">list</span> <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ma</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">memstmt</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEMSTMT</span>: <span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> (<span class="id">mkScopStmt</span> <span class="id">domain</span> <span class="id">schedule</span> <span class="id">mas</span>) <span class="id">memstmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">memnew</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEMNEW_FROM_MEMSTMT</span>: <span class="id">exec_memory_access</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">memstmt</span> <span class="id">ma</span> <span class="id">memnew</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> (<span class="id">mkScopStmt</span> <span class="id">domain</span> <span class="id">schedule</span> (<span class="id">cons</span> <span class="id">ma</span> <span class="id">mas</span>)) <span class="id">memnew</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_stmt_cons_inactive</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">P.PolyT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PT_IN_DOMAIN</span>: <span class="id">P.isPointInPoly</span> <span class="id">viv</span> <span class="id">domain</span> = <span class="id">false</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">P.AffineFnT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mas</span>: <span class="id">list</span> <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> (<span class="id">mkScopStmt</span> <span class="id">domain</span> <span class="id">schedule</span> <span class="id">mas</span>) <span class="id">initmem</span><br/>
&nbsp;&nbsp;.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">isLexGt</span> (<span class="id">l1</span>: <span class="id">list</span> <span class="id">Z</span>) (<span class="id">l2</span>: <span class="id">list</span> <span class="id">Z</span>): <span class="id">bool</span> := <span class="id">false</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">stmtIsScheduledAfter</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>) (<span class="id">vivcur</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">safter</span>: <span class="id">ScopStmt</span>) (<span class="id">sbefore</span>: <span class="id">ScopStmt</span>):=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">isLexGt</span> (<span class="id">evalScopStmtSchedule</span> <span class="id">params</span> <span class="id">vivcur</span> <span class="id">sbefore</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">evalScopStmtSchedule</span> <span class="id">params</span> <span class="id">vivcur</span> <span class="id">safter</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<div class="doc">Execute a scop at a point given that the statements are sorted
      in ASCENDING order: That is, the first element of the list is the lex smallest </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">exec_scop_at_point_sorted_stmts</span>: <span class="id">P.ParamsT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ScopEnvironment</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Scop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_scop_at_point_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mem</span>': <span class="id">Memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_at_point_sorted_stmts</span>  <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> (<span class="id">mkScop</span> []) <span class="id">initmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_scop_at_point_cons</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">curstmt</span>: <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">prevstmts</span>: <span class="id">list</span> <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mem1</span> <span class="id">mem2</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SORTED</span>: <span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ScopStmt</span>) (<span class="id">S_IN_PREV</span>: <span class="id">List.In</span> <span class="id">s</span> <span class="id">prevstmts</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stmtIsScheduledAfter</span> <span class="id">params</span> <span class="id">viv</span> <span class="id">curstmt</span> <span class="id">s</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECPREV</span>: <span class="id">exec_scop_at_point_sorted_stmts</span>  <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> (<span class="id">mkScop</span> <span class="id">prevstmts</span>) <span class="id">mem1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECCUR</span>: <span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">mem1</span> <span class="id">curstmt</span> <span class="id">mem2</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_at_point_sorted_stmts</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> (<span class="id">mkScop</span> (<span class="id">prevstmts</span> ++ [<span class="id">curstmt</span>])) <span class="id">mem2</span>.<br/>
<br/>
<br/>
<div class="doc">sort statement in the ascending order acording to their schedule </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">sortStmtsBySchedAscend</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">l</span>: <span class="id">list</span> <span class="id">ScopStmt</span>): <span class="id">list</span> <span class="id">ScopStmt</span> := <span class="id">l</span>.<br/>
<br/>
<div class="doc">Sort points in ascending order and then execute them </div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">exec_scop_at_point</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">finalmem</span>: <span class="id">Memory</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_at_point_sorted_stmts</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">initmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkScop</span> (<span class="id">sortStmtsBySchedAscend</span> <span class="id">params</span> <span class="id">viv</span> (<span class="id">scopStmts</span> <span class="id">scop</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finalmem</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">getScopDomain</span> (<span class="id">scop</span>: <span class="id">Scop</span>): <span class="id">P.PolyT</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span> <span class="id">P.unionPoly</span> (<span class="id">map</span> <span class="id">scopStmtDomain</span> (<span class="id">scopStmts</span> <span class="id">scop</span>)) <span class="id">P.emptyPoly</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fold_left_reverse_input</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">T</span>: <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">op</span>: <span class="id">T</span> -&gt; <span class="id">T</span> -&gt; <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ts1</span> <span class="id">ts2</span>: <span class="id">list</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">t0</span>: <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">OP_COMMUT</span>: <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">op</span> <span class="id">t1</span> <span class="id">t2</span> = <span class="id">op</span> <span class="id">t2</span> <span class="id">t1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">OP_ASSOC</span>: <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">t3</span>, <span class="id">op</span> (<span class="id">op</span> <span class="id">t1</span> <span class="id">t2</span>) <span class="id">t3</span> = <span class="id">op</span> <span class="id">t1</span> (<span class="id">op</span> <span class="id">t2</span> <span class="id">t3</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold_left</span> <span class="id">op</span> (<span class="id">ts1</span> ++ <span class="id">ts2</span>) <span class="id">t0</span> = <span class="id">fold_left</span> <span class="id">op</span> (<span class="id">ts2</span> ++ <span class="id">ts1</span>) <span class="id">t0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</div>
<div class="proofscript" id="proof4">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ts1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ts1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.app_nil_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">ts2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ts2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">intros</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">List.app_nil_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHts1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">IHts2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHts1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">op</span> (<span class="id">op</span> <span class="id">t0</span> <span class="id">a</span> ) <span class="id">a0</span>) <span class="kwd">with</span> (<span class="id">op</span> (<span class="id">op</span> <span class="id">t0</span> <span class="id">a0</span>) <span class="id">a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">OP_ASSOC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">op</span> <span class="id">a0</span> <span class="id">a</span>) <span class="kwd">with</span> (<span class="id">op</span> <span class="id">a</span> <span class="id">a0</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Check</span> <span class="id">fold_left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fold_left_nest_app</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">T</span>: <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">op</span>: <span class="id">T</span> -&gt; <span class="id">T</span> -&gt; <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ts1</span> <span class="id">ts2</span>: <span class="id">list</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">t0</span>: <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">OP_COMMUT</span>: <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">op</span> <span class="id">t1</span> <span class="id">t2</span> = <span class="id">op</span> <span class="id">t2</span> <span class="id">t1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">OP_ASSOC</span>: <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">t3</span>, <span class="id">op</span> (<span class="id">op</span> <span class="id">t1</span> <span class="id">t2</span>) <span class="id">t3</span> = <span class="id">op</span> <span class="id">t1</span> (<span class="id">op</span> <span class="id">t2</span> <span class="id">t3</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold_left</span> <span class="id">op</span> (<span class="id">ts1</span> ++ <span class="id">ts2</span>) <span class="id">t0</span> = <span class="id">fold_left</span> <span class="id">op</span> <span class="id">ts1</span> (<span class="id">fold_left</span> <span class="id">op</span> <span class="id">ts2</span> <span class="id">t0</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</div>
<div class="proofscript" id="proof5">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ts2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">ts1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ts2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.app_nil_r</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">ts0</span> ++ <span class="id">a</span> :: <span class="id">ts2</span>) <span class="kwd">with</span> ((<span class="id">ts0</span> ++ [<span class="id">a</span>]) ++ <span class="id">ts2</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">a</span> :: <span class="id">ts2</span>) <span class="kwd">with</span> ([<span class="id">a</span>] ++ <span class="id">ts2</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="tactic">rewrite</span> <span class="id">IHts2</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">fold_left_reverse_input</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ts0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHts0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fold_left_pull_out_app</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">T</span>: <span class="kwd">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">op</span>: <span class="id">T</span> -&gt; <span class="id">T</span> -&gt; <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ts</span>: <span class="id">list</span> <span class="id">T</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">OP_COMMUT</span>: <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">op</span> <span class="id">t1</span> <span class="id">t2</span> = <span class="id">op</span> <span class="id">t2</span> <span class="id">t1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">OP_ASSOC</span>: <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">t3</span>, <span class="id">op</span> (<span class="id">op</span> <span class="id">t1</span> <span class="id">t2</span>) <span class="id">t3</span> = <span class="id">op</span> <span class="id">t1</span> (<span class="id">op</span> <span class="id">t2</span> <span class="id">t3</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">t</span> <span class="id">t0</span>: <span class="id">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold_left</span> <span class="id">op</span> (<span class="id">t</span> :: <span class="id">ts</span>) <span class="id">t0</span> = <span class="id">op</span> <span class="id">t</span> (<span class="id">fold_left</span> <span class="id">op</span> <span class="id">ts</span> <span class="id">t0</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</div>
<div class="proofscript" id="proof6">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ts</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ts</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">t0</span> :: <span class="id">a</span> :: <span class="id">ts</span>) <span class="kwd">with</span> ([<span class="id">t0</span>;<span class="id">a</span>] ++ <span class="id">ts</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">fold_left_reverse_input</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">ts</span> ++ [<span class="id">t0</span>; <span class="id">a</span>]) <span class="kwd">with</span> ((<span class="id">ts</span>++ [<span class="id">t0</span>]) ++ [<span class="id">a</span>]); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">fold_left_nest_app</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">fold_left_reverse_input</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> (<span class="id">ls</span>: <span class="id">list</span> <span class="id">T</span>) (<span class="id">l0</span> <span class="id">l1</span>: <span class="id">T</span>), (<span class="id">ls</span> ++ [<span class="id">l0</span>]) ++ [<span class="id">l1</span>] = <span class="id">ls</span> ++ [<span class="id">l0</span>;<span class="id">l1</span>]).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ls</span>; <span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<div class="doc">getScopDomain commutes with unionPoly in a cons *</div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">getScopDomain_cons</span>: <span class="kwd">forall</span> (<span class="id">ss</span>: <span class="id">ScopStmt</span>) (<span class="id">lss</span>: <span class="id">list</span> <span class="id">ScopStmt</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getScopDomain</span> ({| <span class="id">scopStmts</span> := <span class="id">ss</span> :: <span class="id">lss</span> |}) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.unionPoly</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmtDomain</span> <span class="id">ss</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopDomain</span> {| <span class="id">scopStmts</span> := <span class="id">lss</span> |}).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</div>
<div class="proofscript" id="proof7">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getScopDomain</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Opaque</span> <span class="id">fold_left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">map</span> <span class="id">scopStmtDomain</span> <span class="id">lss</span>) <span class="kwd">as</span> <span class="id">ds</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">scopStmtDomain</span> <span class="id">ss</span>) <span class="kwd">as</span> <span class="id">d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">lss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">fold_left_pull_out_app</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Extern</span> 0 (<span class="id">getScopDomain</span> {| <span class="id">scopStmts</span> := ?<span class="id">S</span> :: ?<span class="id">SS</span> |}) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">getScopDomain_cons</span> <span class="id">S</span> <span class="id">SS</span>): <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">getScopDomain_cons</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">getScopDomain_cons</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">exec_scop_from_lexmin</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.ParamsT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ScopEnvironment</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">viv</span> <span class="docright">(* begin VIV, inclusive  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Scop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">Memory</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">viv</span> <span class="docright">(* end VIV, inclusive  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_scop_begin</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">mem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivmin</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIVMIN</span>: <span class="id">vivmin</span> = (<span class="id">P.getLexminPoint</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_SCOP_AT_POINT</span>: <span class="id">exec_scop_at_point</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivmin</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">mem</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_from_lexmin</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vivmin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">initmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">initmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vivmin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">exec_scop_middle</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">initmem</span> <span class="id">mem1</span> <span class="id">mem2</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivbegin</span> <span class="id">vivprev</span> <span class="id">vivcur</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">CUR</span>: <span class="id">Some</span> <span class="id">vivcur</span> = <span class="id">P.getLexNextPoint</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) <span class="id">vivprev</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_SCOP_TILL</span>: <span class="id">exec_scop_from_lexmin</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivbegin</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">mem1</span>  <span class="id">vivprev</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_SCOP_AT_POINT</span>: <span class="id">exec_scop_at_point</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivcur</span> <span class="id">mem1</span> <span class="id">scop</span> <span class="id">mem2</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_from_lexmin</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivbegin</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">mem2</span> <span class="id">vivcur</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">initScopEnvironment</span> : <span class="id">ScopEnvironment</span> := <span class="id">ZMap.init</span> <span class="id">None</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">exec_scop</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">finalmem</span>: <span class="id">Memory</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_scop_from_lexmin</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">initScopEnvironment</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getLexminPoint</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">initmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">finalmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getLexmaxPoint</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>)).<br/>
&nbsp;&nbsp;<span class="kwd">End</span> <span class="id">EVALUATION</span>.<br/>
<br/>
<br/>
<h1>Section about writes </h1>
&nbsp;&nbsp;<span class="kwd">Section</span> <span class="id">WRITES</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<h2>Define what it means for a memory access to not write to memory </h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">MAStoreNoWrite</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.ParamsT</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">VIVSpace</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">MemoryAccess</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">ChunkNum</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">list</span> <span class="id">Z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">mkMAStoreNoWrite</span>: <span class="kwd">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needlechunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needleix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIV_IN_DOMAIN</span>: <span class="id">P.isPointInPoly</span> <span class="id">viv</span> <span class="id">domain</span> = <span class="id">false</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIV_AT_ACCESSFN</span>: <span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv</span> = <span class="id">needleix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">MAStoreNoWrite</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">domain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">needlechunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">needlechunk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">needleix</span>.<br/>
<br/>
<h2>Computational version of the write</h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">MAWriteb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needlechunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needleix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">memacc</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">memacc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Z.eqb</span> <span class="id">needlechunk</span> <span class="id">chunk</span> &amp;&amp; <span class="id">P.isPointInPoly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.invertEvalAffineFn</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">needleix</span>) (<span class="id">domain</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<h2>TODO: SSReflect MAStoreWrite, MAStoreNoWrite, and Mhere *</h2>
<br/>
<h2>Extension of MemoryAccessWritesmemoryatix to statements </h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">scopStmtWriteb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needlechunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needleix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stmt</span>: <span class="id">ScopStmt</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">existsb</span> (<span class="id">MAWriteb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmtDomain</span> <span class="id">stmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">needlechunk</span> <span class="id">needleix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmtMemAccesses</span> <span class="id">stmt</span>).<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<div class="doc">Extension of MAWrites to scops </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">scopWriteb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needlechunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">needleix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>): <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">existsb</span> (<span class="id">scopStmtWriteb</span> <span class="id">params</span> <span class="id">needlechunk</span> <span class="id">needleix</span>) (<span class="id">scopStmts</span> <span class="id">scop</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">scopWriteb_unchanged_on_sorting</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">b</span>: <span class="id">bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopWriteB</span>: <span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span> = <span class="id">b</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{| <span class="id">scopStmts</span> := <span class="id">sortStmtsBySchedAscend</span> <span class="id">params</span> <span class="id">viv</span> (<span class="id">scopStmts</span> <span class="id">scop</span>) |} = <span class="id">b</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</div>
<div class="proofscript" id="proof8">
&nbsp;&nbsp;&nbsp;&nbsp;Admitted.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<h2>If the point of access is not written by the memory access, then the memory access does not change that location </h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">point_not_in_memacc_implies_value_unchanged</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">memacc</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PT_IN_DOMAIN</span>: <span class="id">P.isPointInPoly</span> <span class="id">viv</span> <span class="id">domain</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECMA</span>: <span class="id">exec_memory_access</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> <span class="id">memacc</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">POINT_NOT_IN_POLY</span>: <span class="id">MAWriteb</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">memacc</span> = <span class="id">false</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</div>
<div class="proofscript" id="proof9">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXECMA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;Execute&nbsp;store&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CHUNK_CASES</span>: {<span class="id">chunk</span> = <span class="id">chunk0</span>} + {<span class="id">chunk</span> &lt;&gt; <span class="id">chunk0</span>}). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">MAWriteb</span> <span class="kwd">in</span> <span class="id">POINT_NOT_IN_POLY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">CHUNK_CASES</span> <span class="id">eqn</span>:<span class="id">CASES</span> ; <span class="tactic">auto</span>; <span class="tactic">subst</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;TODO:&nbsp;figure&nbsp;out&nbsp;how&nbsp;to&nbsp;proof&nbsp;automae&nbsp;this&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">chunk0</span> =? <span class="id">chunk0</span>) <span class="kwd">with</span> <span class="id">true</span> <span class="kwd">in</span> *; <span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Z.eqb_refl</span>; <span class="tactic">auto</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">POINT_NOT_IN_POLY</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">IXCASES</span>: {<span class="id">ix</span> =  (<span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv0</span>)} + <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">ix</span> &lt;&gt;  (<span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv0</span>)}). <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IXCASES</span>; <span class="tactic">auto</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">P.invertEvalAffineFn</span> <span class="id">params</span> <span class="id">accessfn</span> (<span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv0</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">with</span> <span class="id">viv0</span> <span class="kwd">in</span> <span class="id">POINT_NOT_IN_POLY</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">proofdb</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">point_not_in_memacc_implies_value_unchanged</span>: <span class="id">proofdb</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">point_not_in_scop_stmt_implies_value_unchanged</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">stmt</span>: <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSTMT</span>: <span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> <span class="id">stmt</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">POINT_NOT_IN_POLY</span>: <span class="id">scopStmtWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">stmt</span> = <span class="id">false</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</div>
<div class="proofscript" id="proof10">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXECSTMT</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scopStmtWriteb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">POINT_NOT_IN_POLY_CONJ</span>: <span class="id">MAWriteb</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">ma</span> = <span class="id">false</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">existsb</span> (<span class="id">MAWriteb</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">chunk</span> <span class="id">ix</span>) <span class="id">mas</span> = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">orb_false_elim</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">POINT_NOT_IN_POLY_CONJ</span> <span class="kwd">as</span> [<span class="id">P_NOT_IN_CUR_WRITE</span>  <span class="id">P_NOT_IN_OTHER_WRITES</span>].<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEMSTMT_EQ_INITMEM</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">memstmt</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEMSTMT_EQ_MEMNEW</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">memnew</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">memstmt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">point_not_in_scop_stmt_implies_value_unchanged</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">point_not_in_write_polyhedra_for_scop_at_point_sorted_stmts_implies_value_unchanged</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOPATPOINT</span>: <span class="id">exec_scop_at_point_sorted_stmts</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">POINT_NOT_IN_POLY</span>: <span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span> = <span class="id">false</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</div>
<div class="proofscript" id="proof11">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXECSCOPATPOINT</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scopWriteb</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">POINT_NOT_IN_POLY_CONJ</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">existsb</span> (<span class="id">scopStmtWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span>) <span class="id">prevstmts</span> = <span class="id">false</span>  /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopStmtWriteb</span> <span class="id">params</span> <span class="id">chunk</span>  <span class="id">ix</span> <span class="id">curstmt</span> = <span class="id">false</span>).<br/>
<div class="doc">TODO: proof automation should have worked </div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">existsb_app_single</span> <span class="kwd">in</span> <span class="id">POINT_NOT_IN_POLY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">orb_false_elim</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">POINT_NOT_IN_POLY_CONJ</span> <span class="kwd">as</span> [<span class="id">P_NOT_IN_CUR_STMT</span>  <span class="id">P_NOT_IN_OTHER_STMTS</span>].<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEMSTMT_EQ_INITMEM</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem2</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">point_not_in_scop_stmt_implies_value_unchanged</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEMSTMT_EQ_MEMNEW</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem1</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHEXECSCOPATPOINT</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">point_not_in_write_polyhedra_for_scop_at_point_sorted_stmts_implies_value_unchanged</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">point_not_in_write_polyhedra_for_scop_at_point_implies_value_unchanged</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOPATPOINT</span>: <span class="id">exec_scop_at_point</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">POINT_NOT_IN_POLY</span>: <span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span> = <span class="id">false</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</div>
<div class="proofscript" id="proof12">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">exec_scop_at_point</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">point_not_in_write_polyhedra_for_scop_at_point_sorted_stmts_implies_value_unchanged</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">EXECSCOPATPOINT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">scopWriteb_unchanged_on_sorting</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">point_not_in_write_polyhedra_for_scop_at_point_implies_value_unchanged</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">point_not_in_write_polyhedra_implies_value_unchanged</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOP</span>: <span class="id">exec_scop</span> <span class="id">params</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">POINT_NOT_IN_POLY</span>: <span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span> = <span class="id">false</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</div>
<div class="proofscript" id="proof13">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">params</span>. <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXECSCOP</span> ;  <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEM1_EQ_MEM</span>: <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem1</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>). <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEM2_EQ_MEM1</span>: <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem2</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">point_not_in_write_polyhedra_implies_value_unchanged</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">point_not_in_write_polyhedra_implies_value_unchanged</span>: <span class="id">proofdb</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">End</span> <span class="id">WRITES</span>.<br/>
<br/>
<br/>
<h1>Section to reason about last writes </h1>
&nbsp;&nbsp;<span class="kwd">Section</span> <span class="id">LASTWRITE</span>.<br/>
<br/>
<h2>The definition of a last write in a scop </h2>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">IsLastWrite</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwma</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwviv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkLastWrite</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lastWriteVivInDomain</span>: <span class="id">P.isPointInPoly</span> <span class="id">lwviv</span> <span class="id">domain</span> = <span class="id">true</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lastWriteVivIx</span>: <span class="id">lwix</span> = <span class="id">evalAccessFunction</span> <span class="id">params</span> (<span class="id">getMAAccessFunction</span> <span class="id">lwma</span>) <span class="id">lwviv</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lastWriteWrite</span>: <span class="id">MAWriteb</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">lwma</span> = <span class="id">true</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lastWriteLast</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">macur</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivcur</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIVCUR_IX</span>: <span class="id">lwix</span> = <span class="id">evalAccessFunction</span> <span class="id">params</span> (<span class="id">getMAAccessFunction</span> <span class="id">macur</span>) <span class="id">vivcur</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIVLW_LT_VIVCUR</span>: <span class="id">P.isLexLT</span>  <span class="id">lwviv</span> <span class="id">vivcur</span> = <span class="id">Some</span> <span class="id">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">MAWriteb</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">macur</span> = <span class="id">false</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Constructors</span> <span class="id">IsLastWrite</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">lastWriteVivInDomain</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">lastWriteVivIx</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">lastWriteWrite</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">lastWriteLast</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<h2>Last write is decidable </h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">IsLastWriteDecidable</span>: <span class="kwd">forall</span>(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ma</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">P.PointT</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">ma</span> <span class="id">chunk</span> <span class="id">viv</span> <span class="id">ix</span>} +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{~<span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">ma</span> <span class="id">chunk</span> <span class="id">viv</span> <span class="id">ix</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</div>
<div class="proofscript" id="proof14">
&nbsp;&nbsp;&nbsp;&nbsp;Admitted.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">IsLastWriteDecidable</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">IsLastWriteDecidable</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWrite_domain_inclusive</span>: <span class="kwd">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">largerdomain</span> <span class="id">smallerdomain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ma</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwviv</span>: <span class="id">P.PointT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SMALLERDOMAIN</span>: <span class="id">P.isPolySubset</span> <span class="id">smallerdomain</span> <span class="id">largerdomain</span> = <span class="id">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">largerdomain</span> <span class="id">ma</span> <span class="id">lwchunk</span> <span class="id">lwviv</span> <span class="id">lwix</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">smallerdomain</span> <span class="id">ma</span> <span class="id">lwchunk</span> <span class="id">lwviv</span> <span class="id">lwix</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</div>
<div class="proofscript" id="proof15">
&nbsp;&nbsp;&nbsp;&nbsp;Admitted.</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">LastWrite_domain_inclusive</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">IsLastWriteDecidable</span>: <span class="id">proofdb</span>.<br/>
<br/>
<div class="doc">Defines a list of memory accesses that do not alias in a domain </div>
<div class="doc">NOTE THAT THIS DEFINITION IGNORES READ / WRITE DISTINCTIONS! This needs
    to be patched up in fugure </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">noWritesAliasInDomain</span> (<span class="id">domain</span>: <span class="id">VIVSpace</span>) (<span class="id">mas</span>: <span class="id">list</span> <span class="id">MemoryAccess</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ma1</span> <span class="id">ma2</span> <span class="id">viv</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIV_IN_DOMAIN</span>: <span class="id">P.isPointInPoly</span> <span class="id">viv</span> <span class="id">domain</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MA1_IN_STMT</span>: <span class="id">List.In</span> <span class="id">ma1</span> <span class="id">mas</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MA2_IN_STMT</span>: <span class="id">List.In</span> <span class="id">ma2</span> <span class="id">mas</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MA1_MA2_ALIAS</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">evalAccessFunction</span> <span class="id">params</span> (<span class="id">getMAAccessFunction</span> <span class="id">ma1</span>) <span class="id">viv</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">evalAccessFunction</span> <span class="id">params</span> (<span class="id">getMAAccessFunction</span> <span class="id">ma2</span>) <span class="id">viv</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ma1</span> = <span class="id">ma2</span>.<br/>
<br/>
<div class="doc">NoWritesAlias on a larger list continues to hold on a sublist </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">noWritesAlias_cons_destruct</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">domain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mas</span>: <span class="id">list</span> <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ma</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOWRITESALIAS</span>: <span class="id">noWritesAliasInDomain</span> <span class="id">domain</span> (<span class="id">ma</span>::<span class="id">mas</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">noWritesAliasInDomain</span> <span class="id">domain</span> <span class="id">mas</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</div>
<div class="proofscript" id="proof16">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">noWritesAliasInDomain</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">NOWRITESALIAS</span>; <span class="tactic">eauto</span>; <span class="tactic">repeat</span> (<span class="tactic">apply</span> <span class="id">List.in_cons</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">noWritesAlias_cons_destruct</span>: <span class="id">proofdb</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<div class="doc">A ScopStmt is valid if none of the writes *in* a scop stmt can alias </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">ScopStmt_noWritesAlias</span> (<span class="id">stmt</span>: <span class="id">ScopStmt</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">noWritesAliasInDomain</span> (<span class="id">scopStmtDomain</span> <span class="id">stmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmtMemAccesses</span> <span class="id">stmt</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">ScopStmt_noWritesAlias</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<h2>Any write that runs after AT last write (LEXCUR_EQ_VIVLW) which aliases with the
last write must write the value the last write wrote </h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWriteImposesMemoryValueAtLastWriteIx_scop_stmt</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stmt</span>: <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivlw</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_SCOP_STMT</span>: <span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span>  <span class="id">vivlw</span> <span class="id">initmem</span> <span class="id">stmt</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwaccessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssvval</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EVAL_LWSSV</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivlw</span> <span class="id">lwssv</span> <span class="id">lwssvval</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> (<span class="id">scopStmtDomain</span> <span class="id">stmt</span>) <span class="id">vivlw</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lwchunk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vivlw</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lwix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE_IN_STMT</span>: <span class="id">List.In</span> (<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmtMemAccesses</span> <span class="id">stmt</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOWRITEALIAS</span>: <span class="id">ScopStmt_noWritesAlias</span> <span class="id">stmt</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">finalmem</span> = <span class="id">Some</span> <span class="id">lwssvval</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</div>
<div class="proofscript" id="proof17">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXEC_SCOP_STMT</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;stmt&nbsp;active&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">LASTWRITE_IN_STMT</span> <span class="kwd">as</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">MA_IS_LASTWRITE</span> | <span class="id">MA_IN_STMT_WRITES</span>].<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;MA&nbsp;is&nbsp;lastwrite&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ma</span>; <span class="tactic">inversion</span> <span class="id">MA_IS_LASTWRITE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">MEMNEW_FROM_MEMSTMT</span>. <span class="tactic">subst</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">STOREVAL_IS_LWSSVVAL</span>: <span class="id">storeval</span> = <span class="id">lwssvval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_scop_store_value_deterministic</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">STOREVAL_IS_LWSSVVAL</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">LASTWRITE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;MA&nbsp;is&nbsp;in&nbsp;the&nbsp;list&nbsp;of&nbsp;stmt&nbsp;writes&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LOADSTMT</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">memstmt</span> = <span class="id">Some</span> <span class="id">lwssvval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHEXEC_SCOP_STMT</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;We&nbsp;can&nbsp;show&nbsp;this&nbsp;from&nbsp;NOWRITESALIAS&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;Consieder&nbsp;cases&nbsp;of&nbsp;MA,&nbsp;either&nbsp;it&nbsp;wrote&nbsp;to&nbsp;the&nbsp;last&nbsp;write,&nbsp;or&nbsp;it&nbsp;didn't.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;it&nbsp;did&nbsp;write&nbsp;to&nbsp;the&nbsp;last&nbsp;write,&nbsp;then&nbsp;it&nbsp;must&nbsp;_be_&nbsp;the&nbsp;last&nbsp;write,&nbsp;thanks<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;NOWRITEALIAS&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">MEMNEW_FROM_MEMSTMT</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">assert</span> (<span class="id">CHUNK_CASES</span>: {<span class="id">chunk</span> = <span class="id">lwchunk</span>} + {<span class="id">chunk</span> &lt;&gt; <span class="id">lwchunk</span>}). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">CHUNK_CASES</span> <span class="kwd">as</span> [<span class="id">CHUNK_EQ</span> | <span class="id">CHUNK_NEQ</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="tactic">rewrite</span> &lt;- <span class="id">LOADSTMT</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>; <span class="tactic">fail</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">CHUNK_EQ</span> <span class="kwd">in</span> *.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">IX_CASES</span>: {<span class="id">accessix</span> = <span class="id">lwix</span>} +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">accessix</span> &lt;&gt; <span class="id">lwix</span>}). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IX_CASES</span> <span class="kwd">as</span> [<span class="id">IX_EQ</span> | <span class="id">IX_NEQ</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> (<span class="tactic">rewrite</span> &lt;- <span class="id">LOADSTMT</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>; <span class="tactic">fail</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IX_EQ</span> <span class="kwd">in</span> *.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CUR_WRITE_IS_LAST_WRITE</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span> = <span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">LASTWRITE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">CHUNK_EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ScopStmt_noWritesAlias</span> <span class="kwd">in</span> <span class="id">NOWRITEALIAS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">noWritesAliasInDomain</span> <span class="kwd">in</span> <span class="id">NOWRITEALIAS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">NOWRITEALIAS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">NOWRITEALIAS</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">ACCESSIX</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">CUR_WRITE_IS_LAST_WRITE</span>. <span class="tactic">subst</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">STOREVAL_IS_LWSSVVAL</span>: <span class="id">storeval</span> = <span class="id">lwssvval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_scop_store_value_deterministic</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Establish&nbsp;that&nbsp;we&nbsp;write&nbsp;the&nbsp;last&nbsp;write&nbsp;value&nbsp;*)</span>&nbsp;Tada,&nbsp;we're&nbsp;done!&nbsp;we've&nbsp;shown&nbsp;that&nbsp;the&nbsp;value&nbsp;we&nbsp;wanted&nbsp;was&nbsp;the&nbsp;last&nbsp;write<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">STOREVAL_IS_LWSSVVAL</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;stmt&nbsp;inactive,&nbsp;contradiction&nbsp;since&nbsp;the&nbsp;last&nbsp;write&nbsp;actually&nbsp;happened&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">LASTWRITE</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PT_IN_DOMAIN</span>': <span class="id">P.isPointInPoly</span> <span class="id">viv0</span> <span class="id">domain</span> = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">P.pointInSubsetPoly</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">lastWriteVivInDomain0</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CONTRA</span>: <span class="id">true</span> = <span class="id">false</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">CONTRA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWriteImposesMemoryValueAtLastWriteIx_exec_scop_at_point</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivlw</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_SCOP_AT_POINT</span>: <span class="id">exec_scop_at_point</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivlw</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwaccessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssvval</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EVAL_LWSSV</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivlw</span> <span class="id">lwssv</span> <span class="id">lwssvval</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) <span class="id">vivlw</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lwchunk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vivlw</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lwix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE_IN_SCOP</span>: <span class="id">List.In</span> (<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopMemoryAccesses</span> <span class="id">scop</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOWRITEALIAS</span>: <span class="id">True</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">finalmem</span> = <span class="id">Some</span> <span class="id">lwssvval</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</div>
<div class="proofscript" id="proof18">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXEC_SCOP_AT_POINT</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">LASTWRITE_IN_SCOP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getScopMemoryAccesses</span> <span class="kwd">in</span> <span class="id">LASTWRITE_IN_SCOP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span> <span class="kwd">in</span> <span class="id">LASTWRITE_IN_SCOP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">LASTWRITE_IN_SCOP</span>) <span class="kwd">as</span> [<span class="id">LASTWRITE_IN_CUR_STMT</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">LASTWRITE_IN_PREV_STMTS</span>].<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;We&nbsp;are&nbsp;executing&nbsp;the&nbsp;current&nbsp;stmt&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWriteImposesMemoryValueAtLastWriteIx_scop_stmt</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWrite_domain_inclusive</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">largerdomain</span> := <span class="id">P.getLexLeqPoly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopDomain</span> {| <span class="id">scopStmts</span> := <span class="id">stmt</span>:: <span class="id">stmts</span> |})<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv0</span>); <span class="tactic">auto</span>.<br/>
<div class="doc">TODO: proof automation should have done this *</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getScopDomain_cons</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P.getLexLeqPoly_proper_wrt_subset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P.subset_of_union</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">admit</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;Lastwrite&nbsp;was&nbsp;in&nbsp;the&nbsp;other&nbsp;statements&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHEXEC_SCOP_AT_POINT</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWrite_domain_inclusive</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">largerdomain</span> := <span class="id">P.getLexLeqPoly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopDomain</span> {| <span class="id">scopStmts</span> := <span class="id">stmt</span>:: <span class="id">stmts</span> |})<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv0</span>); <span class="tactic">auto</span>.<br/>
<div class="doc">TODO: proof automation should have done this *</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getScopDomain_cons</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P.getLexLeqPoly_proper_wrt_subset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">P.unionPoly_commutative</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P.subset_of_union</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<h2>Any write that runs after the last write (LEXCUR_GT_VIVLW) cannot modify the state of memory at the last write </h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWriteImposesMemoryValue_exec_mem_access</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivcur</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">macur</span>: <span class="id">MemoryAccess</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span>: <span class="id">VIVSpace</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_MEM_ACCESS</span>: <span class="id">exec_memory_access</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivcur</span> <span class="id">initmem</span> <span class="id">macur</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIVCUR_IN_DOMAIN</span>: <span class="id">P.isPointInPoly</span> <span class="id">vivcur</span> <span class="id">domain</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivlw</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LEXCUR_GT_VIVLW</span>: <span class="id">P.isLexGT</span> <span class="id">vivcur</span> <span class="id">vivlw</span> = <span class="id">Some</span> <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwaccessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">domain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lwchunk</span> <span class="id">vivlw</span> <span class="id">lwix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</div>
<div class="proofscript" id="proof19">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXEC_MEM_ACCESS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;cur&nbsp;&gt;&nbsp;lw&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CHUNK_CASES</span>: {<span class="id">lwchunk</span> = <span class="id">chunk</span>} + {<span class="id">lwchunk</span> &lt;&gt; <span class="id">chunk</span>}); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">CHUNK_CASES</span> <span class="kwd">as</span> [<span class="id">EQ</span> | <span class="id">NEQ</span>]; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EQ</span> <span class="kwd">in</span> *. <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">IX_CASES</span>: {<span class="id">lwix</span> = <span class="id">accessix</span>} + {<span class="id">lwix</span> &lt;&gt; <span class="id">accessix</span>}); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IX_CASES</span> <span class="kwd">as</span> [<span class="id">IXEQ</span> | <span class="id">IXNEQ</span>]; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
<div class="doc">From the fact that the write perfectly aliases, we can conclucde
      that this write does write into the last write ix </div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">WRITE_IN_LW</span>: <span class="id">MAWriteb</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">lwchunk</span> <span class="id">lwix</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>)= <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">andb_true_intro</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;However,&nbsp;from&nbsp;the&nbsp;fact&nbsp;that&nbsp;we&nbsp;have&nbsp;a&nbsp;_last&nbsp;write_,&nbsp;and&nbsp;that&nbsp;vivcur&nbsp;&gt;&nbsp;vivlw,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;cannot&nbsp;happen!&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">WRITE_NOT_IN_LW</span>: <span class="id">MAWriteb</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">lwchunk</span> <span class="id">lwix</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">lastWriteLast</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<div class="doc">TODO: this should automatically work, figure out why it is not </div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">P.isLexLT_GT</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;Boom&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CONTRA</span>: <span class="id">true</span> = <span class="id">false</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">LastWriteImposesMemoryValue_exec_mem_access</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<h2>Any stmt that runs after the last write cannot edit the last write value of memory *</h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWriteImposesMemoryValue_exec_scop_stmt</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivcur</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stmt</span>: <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_SCOP_STMT</span>: <span class="id">exec_scop_stmt</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivcur</span> <span class="id">initmem</span> <span class="id">stmt</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivlw</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LEXCUR_GT_VIVLW</span>: <span class="id">P.isLexGT</span> <span class="id">vivcur</span> <span class="id">vivlw</span> = <span class="id">Some</span> <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwaccessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span> (<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> (<span class="id">scopStmtDomain</span> <span class="id">stmt</span>) <span class="id">vivcur</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>) <span class="id">lwchunk</span> <span class="id">vivlw</span> <span class="id">lwix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</div>
<div class="proofscript" id="proof20">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXEC_SCOP_STMT</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEMSTMT</span>: <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">memstmt</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">initmem</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHEXEC_SCOP_STMT</span>; <span class="tactic">eauto</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEMNEW</span>: <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">memnew</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">memstmt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWriteImposesMemoryValue_exec_mem_access</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">domain</span> := (<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> <span class="id">domain</span> <span class="id">viv0</span>)); <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">LastWriteImposesMemoryValue_exec_scop_stmt</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<h2>Executing the scop at any point after the last write cannot edit the last write value of memory *</h2>
<div class="doc">TODO: we should be able to convert this repetition into some kind of "scheme" that lets us generalize results about memory accesses into those of scopStmt and ScopAtPoint. Think about this *</div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWriteImposesMemoryValue_exec_scop_at_point</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivcur</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXEC_SCOP_AT_POINT</span>: <span class="id">exec_scop_at_point</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivcur</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivlw</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LEXCUR_GT_VIVLW</span>: <span class="id">P.isLexGT</span> <span class="id">vivcur</span> <span class="id">vivlw</span> = <span class="id">Some</span> <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwaccessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span> (<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) <span class="id">vivcur</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>) <span class="id">lwchunk</span> <span class="id">vivlw</span> <span class="id">lwix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">finalmem</span> = <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">initmem</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</div>
<div class="proofscript" id="proof21">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXEC_SCOP_AT_POINT</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getScopDomain_cons</span> <span class="kwd">in</span> *.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SUBSET1</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.isPolySubset</span> (<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> (<span class="id">scopStmtDomain</span> <span class="id">stmt</span>) <span class="id">viv0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getLexLeqPoly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.unionPoly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scopStmtDomain</span> <span class="id">stmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopDomain</span> {| <span class="id">scopStmts</span> := <span class="id">stmts</span> |})) <span class="id">viv0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SUBSET2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.isPolySubset</span> (<span class="id">P.getLexLeqPoly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span> (<span class="id">getScopDomain</span> {| <span class="id">scopStmts</span> := <span class="id">stmts</span> |}) <span class="id">viv0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getLexLeqPoly</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.unionPoly</span> (<span class="id">scopStmtDomain</span> <span class="id">stmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getScopDomain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{| <span class="id">scopStmts</span> := <span class="id">stmts</span> |})) <span class="id">viv0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P.getLexLeqPoly_proper_wrt_subset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">P.unionPoly_commutative</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P.subset_of_union</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEM2</span>: <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">mem2</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">mem1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHEXEC_SCOP_AT_POINT</span>; <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWrite_domain_inclusive</span>; <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEM1</span>: <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">mem1</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">initmem</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWriteImposesMemoryValue_exec_scop_stmt</span>; <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWrite_domain_inclusive</span>; <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWriteImposesMemoryValue_exec_scop</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivstart</span> <span class="id">vivend</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOP</span>: <span class="id">exec_scop_from_lexmin</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivstart</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span> <span class="id">vivend</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwchunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lwaccessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivlw</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIVEND_GE_VIVLW</span>: <span class="id">P.isLexGT</span> <span class="id">vivend</span> <span class="id">vivlw</span> = <span class="id">Some</span> <span class="id">true</span> \/ <span class="id">vivend</span> = <span class="id">vivlw</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span> (<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) <span class="id">vivend</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">lwchunk</span> <span class="id">lwaccessfn</span> <span class="id">lwssv</span>) <span class="id">lwchunk</span> <span class="id">vivlw</span> <span class="id">lwix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">storeval</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECWRITEVAL</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivlw</span> <span class="id">lwssv</span> <span class="id">storeval</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">finalmem</span> = <span class="id">Some</span> <span class="id">storeval</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</div>
<div class="proofscript" id="proof22">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXECSCOP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
<br/>
&nbsp;the&nbsp;min&nbsp;point&nbsp;is&nbsp;greater&nbsp;than&nbsp;the&nbsp;last&nbsp;write,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;is&nbsp;nonsense,&nbsp;so&nbsp;contradiction&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VIVLW_IN_DOMAIN</span>: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.isPointInPoly</span> <span class="id">vivlw</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P.getLexLeqPoly</span> <span class="id">params</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) <span class="id">vivmin</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VIVMIN</span> <span class="kwd">in</span> <span class="id">VIVLW_IN_DOMAIN</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VIVLW_IN_VIVMIN_POLYHEDRA</span>: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.isPointInPoly</span> <span class="id">vivlw</span> (<span class="id">P.pointToPoly</span> <span class="id">vivmin</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VIVMIN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">VIVLW_IN_DOMAIN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VIVLW_EQ_VIVMIN</span>: <span class="id">vivlw</span> = <span class="id">vivmin</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CONTRA</span>: <span class="id">P.isLexGT</span> <span class="id">vivmin</span> <span class="id">vivlw</span> = <span class="id">Some</span> <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VIVLW_EQ_VIVMIN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;Second&nbsp;part&nbsp;of&nbsp;proof.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
<br/>
&nbsp;vivprev&nbsp;--(+1)--&gt;&nbsp;vivcur&nbsp;*)</span>&nbsp;vivlw&nbsp;---(&lt;)--&gt;&nbsp;vivcur&nbsp;*)</span>&nbsp;vivlw&nbsp;---(&lt;=)--&gt;&nbsp;vivprev&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VIVLW_VIVPREV_CASES</span>: <span class="id">P.isLexLT</span> <span class="id">vivlw</span> <span class="id">vivprev</span> = <span class="id">Some</span> <span class="id">true</span> \/ <span class="id">vivlw</span> = <span class="id">vivprev</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">P.isLexLT_next_implies_isLexLEQ_current</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">P.isLexLT_GT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">VIVLW_VIVPREV_CASES</span> <span class="kwd">as</span> [<span class="id">VIVLW_LT_PREV</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VIVLW_EQ_PREV</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">assert</span> (<span class="id">MEM1</span>: <span class="id">loadMemory</span> <span class="id">lwchunk</span> <span class="id">lwix</span> <span class="id">mem1</span> = <span class="id">Some</span> <span class="id">storeval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHEXECSCOP</span>; <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">P.isLexLT_GT</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">admit</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">LastWriteImposesMemoryValue_exec_scop_from_lexmin</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lexstart</span> <span class="id">lexcur</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOP</span>: <span class="id">exec_scop_from_lexmin</span> <span class="id">params</span> <span class="id">se</span> <span class="id">lexstart</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span> <span class="id">lexcur</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stmt</span>: <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vivlw</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LEXCUR_GT_VIVLW</span>: <span class="id">P.isLexGT</span> <span class="id">lexstart</span> <span class="id">vivlw</span> = <span class="id">Some</span> <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">scop</span> <span class="id">stmt</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) <span class="id">chunk</span> <span class="id">vivlw</span> <span class="id">ix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">storeval</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECWRITEVAL</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">vivlw</span> <span class="id">ssv</span> <span class="id">storeval</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> = <span class="id">Some</span> <span class="id">storeval</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</div>
<div class="proofscript" id="proof23">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXECSCOP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;In&nbsp;the&nbsp;beginning,&nbsp;we&nbsp;would&nbsp;not&nbsp;have&nbsp;executed&nbsp;the&nbsp;last&nbsp;write,&nbsp;so&nbsp;this&nbsp;is&nbsp;absurd&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CONTRA</span>: <span class="id">true</span> = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">P.isLexGT_of_lexmin_is_always_false</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEM1</span>: <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem1</span> = <span class="id">Some</span> <span class="id">storeval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHEXECSCOP</span>; <span class="tactic">eauto</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEM2</span>: <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem2</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem1</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<h1>If we have a last write, then the value in memory is the value written by the last write </h1>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Theorem</span> <span class="id">LastWriteImposesMemoryValue</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span>: <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOP</span>: <span class="id">exec_scop</span> <span class="id">params</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stmt</span>: <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ssv</span>: <span class="id">ScopStoreValue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">viv</span>: <span class="id">viv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIV_WITNESS</span>: <span class="id">evalAccessFunction</span> <span class="id">params</span>  <span class="id">accessfn</span> <span class="id">viv</span> = <span class="id">ix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">scop</span> <span class="id">stmt</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) <span class="id">chunk</span> <span class="id">viv</span> <span class="id">ix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">storeval</span>: <span class="id">Value</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">se</span>: <span class="id">ScopEnvironment</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECWRITEVAL</span>: <span class="id">exec_scop_store_value</span> <span class="id">params</span> <span class="id">se</span> <span class="id">viv</span> <span class="id">ssv</span> <span class="id">storeval</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> = <span class="id">Some</span> <span class="id">storeval</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</div>
<div class="proofscript" id="proof24">
<div class="doc">Show that we can split scop execution into two parts: The first part that is
       *till* the last write, and the second part that is *after* the last write </div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">EXECSCOP</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;We&nbsp;are&nbsp;starting&nbsp;execution.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">EXECWRITEVAL</span>; <span class="tactic">subst</span>.<br/>
<br/>
<div class="doc">Show that on the part *till* the last write, the last write value
          is the value of the scop execution </div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">End</span> <span class="id">LASTWRITE</span>.<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">LastWriteImposesMemoryValue</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">LastWriteImposesMemoryValue</span>: <span class="id">proofdb</span>.<br/>
<br/>
<h1>Schedule properties and interactions with last writes </h1>
&nbsp;&nbsp;<span class="kwd">Section</span> <span class="id">SCHEDULE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">validSchedule</span> (<span class="id">scop</span>: <span class="id">Scop</span>) (<span class="id">schedule</span>: <span class="id">Schedule</span>) (<span class="id">scop</span>': <span class="id">Scop</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkValidSchedule</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NEWSCOP_IS_SCHEDULED_OLDSCOP</span>: (<span class="id">scop</span>' = <span class="id">applyScheduleToScop</span> <span class="id">schedule</span> <span class="id">scop</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">RESPECTSRAW</span>: <span class="id">scheduleRespectsRAW</span> <span class="id">schedule</span> <span class="id">scop</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">RESPECTSWAW</span>: <span class="id">scheduleRespectsWAW</span> <span class="id">schedule</span> <span class="id">scop</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<div class="doc">Given a point in a write polyhedra, show that there must exist
    a corresponding write in the scop </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">point_in_write_polyhedra_implies_last_write_exists</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">POINT_IN_POLY</span>: <span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span> = <span class="id">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">stmt</span> <span class="id">accessfn</span> <span class="id">ssv</span> <span class="id">viv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> <span class="id">stmt</span> (<span class="id">scopStmts</span> <span class="id">scop</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) (<span class="id">scopStmtMemAccesses</span> <span class="id">stmt</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv</span> = <span class="id">ix</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.isPointInPoly</span> <span class="id">viv</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) = <span class="id">true</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">scop</span> <span class="id">stmt</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) <span class="id">chunk</span> <span class="id">viv</span> <span class="id">ix</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</div>
<div class="proofscript" id="proof25">
&nbsp;&nbsp;&nbsp;&nbsp;Admitted.</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">point_in_write_polyhedra_implies_last_write_exists</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">point_in_write_polyhedra_implies_last_write_exists</span>: <span class="id">proofdb</span>.<br/>
<br/>
<br/>
<div class="doc">a valid schedule preserves inclusion and exclusion into the write
    polyhedra *</div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">valid_schedule_preserves_write_polyhedra_non_containment</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span> <span class="id">scop</span>': <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">Schedule</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALIDSCHEDULE</span>: <span class="id">validSchedule</span> <span class="id">scop</span> <span class="id">schedule</span> <span class="id">scop</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOTINPOLY</span>: <span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span> = <span class="id">false</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span>' = <span class="id">false</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</div>
<div class="proofscript" id="proof26">
&nbsp;&nbsp;&nbsp;&nbsp;Admitted.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">valid_schedule_preserves_write_polyhedra_non_containment</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">valid_schedule_preserves_write_polyhedra_non_containment</span>: <span class="id">proofdb</span>.<br/>
<br/>
<h2>Last write in SCOP =&gt; last write in SCOP'</h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">transport_write_along_schedule</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">scop</span> <span class="id">scop</span>': <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stmt</span>: <span class="id">ScopStmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">Schedule</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALIDSCHEDULE</span>: <span class="id">validSchedule</span> <span class="id">scop</span> <span class="id">schedule</span> <span class="id">scop</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">accessfn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ssv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STMT_IN_SCOP</span>: <span class="id">List.In</span> <span class="id">stmt</span> (<span class="id">scopStmts</span> <span class="id">scop</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STORE_IN_STMT</span>: <span class="id">List.In</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) (<span class="id">scopStmtMemAccesses</span> <span class="id">stmt</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ACCESSFN</span>: <span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv</span> = <span class="id">ix</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VIV_IN_SCOP</span>: <span class="id">P.isPointInPoly</span> <span class="id">viv</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LASTWRITE</span>: <span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">scop</span> <span class="id">stmt</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) <span class="id">chunk</span> <span class="id">viv</span> <span class="id">ix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">scop</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">applyScheduleToScopStmt</span> <span class="id">schedule</span> <span class="id">stmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) <span class="id">chunk</span> <span class="id">viv</span> <span class="id">ix</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</div>
<div class="proofscript" id="proof27">
&nbsp;&nbsp;&nbsp;&nbsp;Admitted.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">End</span> <span class="id">SCHEDULE</span>.<br/>
<br/>
<h1>Section that formalises the proof </h1>
&nbsp;&nbsp;<span class="kwd">Section</span> <span class="id">PROOF</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">MemExtesionallyEqual</span> (<span class="id">mem1</span> <span class="id">mem2</span>: <span class="id">Memory</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">chunk</span>: <span class="id">ChunkNum</span>) (<span class="id">ix</span>: <span class="id">list</span> <span class="id">Z</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem1</span> = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">mem2</span>.<br/>
<br/>
<br/>
<br/>
<br/>
<h2>Stores of reads are disallowed currrently *</h2>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Axiom</span> <span class="id">NoSSVLoadedVal</span>: <span class="kwd">forall</span> (<span class="id">stmt</span>: <span class="id">ScopStmt</span>) (<span class="id">scop</span>: <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">ChunkNum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">accessfn</span>: <span class="id">AccessFunction</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ident</span>: <span class="id">ScopLoadIdent</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> <span class="id">stmt</span> (<span class="id">scopStmts</span> <span class="id">scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">In</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> (<span class="id">SSVLoadedVal</span> <span class="id">ident</span>)) (<span class="id">scopStmtMemAccesses</span> <span class="id">stmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id">False</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">transport_write_along_schedule</span>: <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">transport_write_along_schedule</span>: <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Theorem</span> <span class="id">valid_schedule_preserves_semantics</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">scop</span> <span class="id">scop</span>': <span class="id">Scop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">schedule</span>: <span class="id">Schedule</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALIDSCHEDULE</span>: <span class="id">validSchedule</span> <span class="id">scop</span> <span class="id">schedule</span> <span class="id">scop</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initmem</span> <span class="id">finalmem</span> <span class="id">finalmem</span>': <span class="id">Memory</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">params</span>: <span class="id">P.ParamsT</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOP</span>: <span class="id">exec_scop</span> <span class="id">params</span> <span class="id">initmem</span> <span class="id">scop</span> <span class="id">finalmem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXECSCOP</span>': <span class="id">exec_scop</span> <span class="id">params</span> <span class="id">initmem</span> <span class="id">scop</span>' <span class="id">finalmem</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">MemExtesionallyEqual</span> <span class="id">finalmem</span> <span class="id">finalmem</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</div>
<div class="proofscript" id="proof28">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">MemExtesionallyEqual</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">scopWriteb</span>  <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span>) <span class="id">eqn</span>: <span class="id">POINTINPOLY_CASES</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;write&nbsp;in&nbsp;poly&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">POINTINPOLY_CASES</span> <span class="id">into</span> <span class="id">POINT_IN_POLY</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">WRITEINPOLY</span>: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">stmt</span> <span class="id">accessfn</span> <span class="id">ssv</span> <span class="id">viv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> <span class="id">stmt</span> (<span class="id">scopStmts</span> <span class="id">scop</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) (<span class="id">scopStmtMemAccesses</span> <span class="id">stmt</span>)  /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">evalAccessFunction</span> <span class="id">params</span> <span class="id">accessfn</span> <span class="id">viv</span> = <span class="id">ix</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P.isPointInPoly</span> <span class="id">viv</span> (<span class="id">getScopDomain</span> <span class="id">scop</span>) = <span class="id">true</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IsLastWrite</span> <span class="id">params</span> <span class="id">scop</span> <span class="id">stmt</span> (<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>) <span class="id">chunk</span> <span class="id">viv</span> <span class="id">ix</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">WRITEINPOLY</span> <span class="kwd">as</span> (<span class="id">stmt</span> &amp; <span class="id">accessfn</span> &amp; <span class="id">ssv</span> &amp; <span class="id">viv</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">STMT_IN_SCOP</span> &amp; <span class="id">MEM_IN_STMT</span> &amp; <span class="id">EVALACCESSFN</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VIV_IN_DOMAIN</span> &amp; <span class="id">LASTWRITE</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LASTWRITE_SCOP</span>': <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IsLastWrite</span> <span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scop</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">applyScheduleToScopStmt</span> <span class="id">schedule</span> <span class="id">stmt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAStore</span> <span class="id">chunk</span> <span class="id">accessfn</span> <span class="id">ssv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">chunk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ix</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transport_write_along_schedule</span>; <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ssv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;Pure&nbsp;Function&nbsp;of&nbsp;indvars&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">execSSV</span>: <span class="kwd">forall</span> <span class="id">se</span>, <span class="id">exec_scop_store_value</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">params</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">viv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SSVIndvarFn</span> <span class="id">indvarfn</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">indvarfn</span> (<span class="id">P.evalPoint</span> <span class="id">params</span> <span class="id">viv</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEMWRITE</span>: <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">indvarfn</span> (<span class="id">P.evalPoint</span> <span class="id">params</span> <span class="id">viv</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWriteImposesMemoryValue</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MEM</span>'<span class="id">WRITE</span>: <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span>' =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">indvarfn</span> (<span class="id">P.evalPoint</span> <span class="id">params</span> <span class="id">viv</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LastWriteImposesMemoryValue</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;Function&nbsp;of&nbsp;memory&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">AXIOM_CONTRA</span>: <span class="id">False</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">NoSSVLoadedVal</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rename</span> <span class="id">POINTINPOLY_CASES</span> <span class="id">into</span> <span class="id">POINT_NOT_IN_POLY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">POINT_NOT_IN_POLY</span>': <span class="id">scopWriteb</span> <span class="id">params</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">scop</span>' = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">proofdb</span>.<br/>
<br/>
&nbsp;Write&nbsp;not&nbsp;in&nbsp;poly&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LOAD_FINALMEM</span>: <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span>  = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">point_not_in_write_polyhedra_implies_value_unchanged</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LOAD_FINALMEM</span>': <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">finalmem</span>'  = <span class="id">loadMemory</span> <span class="id">chunk</span> <span class="id">ix</span> <span class="id">initmem</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">point_not_in_write_polyhedra_implies_value_unchanged</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
<br/>
<div class="doc">TODO: I need to track the scopEnvironment in some lemma. This
        scopEnvironment is never instantiated in execSSV. Somewhere, some theorem should
        refer to a specific environment *</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Unshelve</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">initScopEnvironment</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">initScopEnvironment</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;<span class="kwd">End</span> <span class="id">PROOF</span>.<br/>
<span class="kwd">End</span> <span class="id">SCOP</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
